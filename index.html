<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="LiangIter">
<meta property="og:url" content="http://liangiter.top/index.html">
<meta property="og:site_name" content="LiangIter">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LiangIter">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://liangiter.top/"/>





  <title>LiangIter</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta custom-logo">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LiangIter</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://liangiter.top/2018/09/25/十步学习法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiangIter">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/25/十步学习法/" itemprop="url">十步学习法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-25T19:59:29+08:00">
                2018-09-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>最近在看《软技能：代码之外的生存指南》，作者分享他自己的学习方法——十步学习法。自己感觉平时学习新技术套路大致也是这样，不过自己并没有做过细致的总结和归纳，这里做一个简单的摘录和分享，详细情况可以去阅读原作，作者是一位充满激情、兴趣广泛、热爱生活、热爱思考而小有成就的技术人员，书本与技术有关，而不局限于技术，对任何人都有借鉴意义。</p>
</blockquote>
<h2 id="十步学习法"><a href="#十步学习法" class="headerlink" title="十步学习法"></a>十步学习法</h2><h3 id="1-了解全局"><a href="#1-了解全局" class="headerlink" title="1.了解全局"></a>1.了解全局</h3><h3 id="2-确定范围"><a href="#2-确定范围" class="headerlink" title="2.确定范围"></a>2.确定范围</h3><h3 id="3-定义目标"><a href="#3-定义目标" class="headerlink" title="3.定义目标"></a>3.定义目标</h3><h3 id="4-寻找资源"><a href="#4-寻找资源" class="headerlink" title="4.寻找资源"></a>4.寻找资源</h3><h3 id="5-创建学习计划"><a href="#5-创建学习计划" class="headerlink" title="5.创建学习计划"></a>5.创建学习计划</h3><h3 id="6-筛选资源"><a href="#6-筛选资源" class="headerlink" title="6.筛选资源"></a>6.筛选资源</h3><h3 id="7-开始学习，浅尝辄止"><a href="#7-开始学习，浅尝辄止" class="headerlink" title="7.开始学习，浅尝辄止"></a>7.开始学习，浅尝辄止</h3><h3 id="8-动手操作，边学边玩"><a href="#8-动手操作，边学边玩" class="headerlink" title="8.动手操作，边学边玩"></a>8.动手操作，边学边玩</h3><h3 id="9-全面掌握，学以致用"><a href="#9-全面掌握，学以致用" class="headerlink" title="9.全面掌握，学以致用"></a>9.全面掌握，学以致用</h3><h3 id="10-了为人师，融会贯通"><a href="#10-了为人师，融会贯通" class="headerlink" title="10.了为人师，融会贯通"></a>10.了为人师，融会贯通</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://liangiter.top/2018/09/25/垃圾回收机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiangIter">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/25/垃圾回收机制/" itemprop="url">垃圾回收机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-25T17:16:45+08:00">
                2018-09-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>近期公司技术分享讲座十分火热，近期我做了有关垃圾回收机制的分享，整理一下文档</p>
</blockquote>
<h3 id="垃圾回收背景"><a href="#垃圾回收背景" class="headerlink" title="垃圾回收背景"></a>垃圾回收背景</h3><blockquote>
<p>John McCarthy 身为 Lisp 之父和人工智能之父，同时，他也是 GC 之父。1960 年，他在其论文中首次发布了 GC 算法（其实是委婉的提出😂）。而 Java 的前身 Oak 是在 1990 发布的，利用 JVM 实现了跨平台。GC 因此一举成名。</p>
</blockquote>
<h3 id="垃圾回收基本概念"><a href="#垃圾回收基本概念" class="headerlink" title="垃圾回收基本概念"></a>垃圾回收基本概念</h3><p>基本概念:</p>
<ul>
<li>全集</li>
<li>根集</li>
<li>可达到的对象集合</li>
<li>不可达到的对象集合</li>
</ul>
<h4 id="垃圾的定义"><a href="#垃圾的定义" class="headerlink" title="垃圾的定义"></a>垃圾的定义</h4><p>引用《垃圾回收的算法与实现》书中的话:</p>
<blockquote>
<p>把分配到堆中那些不能通过程序引用的对象称为非活动对象，也就是死掉的对象，我们称为“垃圾”。</p>
</blockquote>
<ul>
<li>程序无法访问的对象</li>
<li>GC 收集器需要能正确找到垃圾对象并销毁之</li>
</ul>
<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>因为我们期望让内存管理变得自动（只管用内存，不管内存的回收），我们就必须做两件事情：</p>
<blockquote>
<p>找到内存空间里的垃圾回收垃圾，让程序员能再次利用这部分空间 [1] 只要满足这两项功能的程序，就是 GC，不论它是在 JVM 中，还是在 Ruby 的 VM 中。但这只是两个需求，并没有说明 GC 应该何时找垃圾，何时回收垃圾等等更具体的问题，各类 GC 算法就是在这些更具体问题的处理方式上施展手脚。</p>
</blockquote>
<h4 id="全集"><a href="#全集" class="headerlink" title="全集"></a>全集</h4><ul>
<li>进程内存中全部对象的集合</li>
<li>以 Python 为例:</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gc.get_objects()</span><br></pre></td></tr></table></figure>
<h4 id="根集"><a href="#根集" class="headerlink" title="根集"></a>根集</h4><ul>
<li>不用通过引用关系,可以直接访问对象的集合</li>
</ul>
<h4 id="可达对象集合"><a href="#可达对象集合" class="headerlink" title="可达对象集合"></a>可达对象集合</h4><ul>
<li>根集的对象</li>
<li>通过可达对象,利用引用关系遍历到的所有对象<br><img src="/2018/09/25/垃圾回收机制/reachable.png" alt="imag"></li>
</ul>
<h4 id="不可达到的对象集合"><a href="#不可达到的对象集合" class="headerlink" title="不可达到的对象集合"></a>不可达到的对象集合</h4><ul>
<li>全集与可达对象集合差集</li>
<li>不可达对象是垃圾</li>
<li>Python 中 gc.collect()后垃圾存在列表 gc.grabage 中</li>
</ul>
<h4 id="垃圾回收的优点"><a href="#垃圾回收的优点" class="headerlink" title="垃圾回收的优点"></a>垃圾回收的优点</h4><ul>
<li>提高编程效率</li>
<li>避免内存泄漏</li>
<li>野指针 (悬垂指针)</li>
<li>释放错误的内存</li>
</ul>
<blockquote>
<p>内存泄露：忘记释放了某一部分内存，会导致那部分内存不可用，并占用总的内存空间。如果这一现象持续发生，会引起内存被占满，系统崩溃悬垂指针：忘记初始化指向释放了的内存的指针。这会导致再次调用指针时，该指针指向空内存，引起 bug 释放错误的内存：人为的操作难免会发生错误，如果释放了错误的内存，也会导致程序发生莫名其妙的 bug</p>
</blockquote>
<blockquote>
<p>由此可见垃圾回收的重要性，既可以减少程序员的工作量，更重要的是可以避免很多不必要的错误。</p>
</blockquote>
<h4 id="垃圾回收缺点"><a href="#垃圾回收缺点" class="headerlink" title="垃圾回收缺点"></a>垃圾回收缺点</h4><ul>
<li>垃圾回收消耗cpu，影响程序性能</li>
</ul>
<h4 id="垃圾回收性能评价"><a href="#垃圾回收性能评价" class="headerlink" title="垃圾回收性能评价"></a>垃圾回收性能评价</h4><ul>
<li>垃圾回收总时间</li>
<li>进程突然的停顿</li>
<li>空间利用 —— 减少内存碎片 - 空间连续性、时间连续性</li>
<li>以上要求互相制衡，需要折中</li>
</ul>
<h3 id="主流垃圾回收策略"><a href="#主流垃圾回收策略" class="headerlink" title="主流垃圾回收策略"></a>主流垃圾回收策略</h3><p>John McCarthy 身为 Lisp 之父和人工智能之父，同时，他也是 GC 之父。1960 年，他在其论文中首次发布了 GC 算法（其实是委婉的提出😂）。</p>
<p>标记-清除算法 由 John McCarthy 在 1960 年提出 引用计数法 由 George E. Collins 在 1960 年提出 此算法会有循环引用问题，Harold McBeth 1963 年指出。 复制算法 由 Marvin L. Minsky 在 1963 年提出</p>
<p>《垃圾回收》的作者认为：</p>
<blockquote>
<p>从 50 年前 GC 算法首次发布以来，众多研究者对其进行了各种各样的研究，因此许多 GC 算法也得以发布。[2] 但事实上，这些算法只不过是把前文中提到的三种算法进行组合或应用。也可以这么说，1963 年 GC 复制算法诞生时，GC 的根本性内容就已经完成了。</p>
</blockquote>
<h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>垃圾回收关注的是对于不会再次被使用的对象的内存回收，换一种说法，对于会被垃圾回收清理的对象（内存），不会再次的被其他对象引用。那么可以为每一个对象引入一个计数器，对于任意一个对象，每有一次对这个对象的引用，就将计数器加 1；结束对这个对象的引用，再将计数器减 1；一旦计数器归 0，则表示这个对象可以被清除。这就是引用计数法。</p>
<p>由于在计数器归 0 后，可以立即知道这个对象成为了垃圾，所以引用计数法有着即使回收的优点。同样，这个算法也不是完美的，存在着一定的缺点：</p>
<ul>
<li>占用资源：因为每个对象都需要维护一个计数器，每次指针有更新都伴随着计数器的更新，一定程度上占用了计算资源</li>
<li>占用内存：计数器需要占用一定的内存，为了安全起见，计数器值的上限要大于所有对象的上限，这也是一笔不小的开销</li>
<li>实现复杂：虽然引用计数的思想简单，但是实现起来却不那么容易。各位可以思考下，如果自己编写这一算法，该如何实现？</li>
<li>无法解决循环引用：就像会有狗狗喜欢咬自己的尾巴，把自己咬成环，对象也会存在循环的引用。假设两个对象 a 和 b，a 有指向 b 的指针，b 有指向 a 的指针。二者可能一起成为垃圾，一旦这种情况发生，由于存在对对方的引用，它们的计数器永远都不会归 0，它们也不会被回收</li>
</ul>
<h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p>正如算法的名字，标记清除法可以划分成两个阶段，标记和清除：</p>
<ul>
<li>标记</li>
<li><ul>
<li>标记根集中的所有对象为可达</li>
</ul>
</li>
<li><ul>
<li>从根集中的对象遍历，将其引用的对象标记为可达</li>
</ul>
</li>
<li><ul>
<li>迭代第二步，找到所有可达对象</li>
</ul>
</li>
<li><p>清除</p>
</li>
<li><ul>
<li>全集与可达对象集合的差集，标记为不可达对象集合</li>
</ul>
</li>
<li><ul>
<li>销毁所有不可达对象</li>
</ul>
</li>
</ul>
<p><img src="/2018/09/25/垃圾回收机制/ref_count.png" alt="imag"></p>
<p>优点</p>
<ul>
<li>思路简单，实现简单，是这个算法的一大优点.</li>
<li>没有额外内存开销</li>
<li>可以正确销毁循环引用的对象</li>
</ul>
<p>缺点</p>
<p>简单也意味着在其他部分有所牺牲，从上图我们可以看出一些端倪：碎片化：由于只是将垃圾对象清除掉，对于存活对象不做处理，所以由于存活对象分布的不连续性，会导致可用内存被分割成一块块的。如果有一个新的对象请求内存，需要去内存中寻找，哪一个空闲块（可用一个链表来维护空闲块的位置）足够满足这个对象的需求。更极端的情况，空闲的总内存大于对象请求的空间，却没有足够的连续空闲空间，来完成内存的分配。与写时复制技术不兼容：写时复制（Copy On Write）是一个很重要的思想，可以优化内存占用或者提升并发环境下的性能。顾名思义，这一技术是在有写入的时候，对内存进行复制，以达到一定的优化目的。而标记清除算法的标记过程，就是一次对内存（对象头）的写入，会不断地引起内存复制。因此标记清除算法与此技术并不互相兼容</p>
<ul>
<li>标记-清除操作时间消耗较大，程序会顿卡</li>
<li>对象不可达后，销毁有延时</li>
</ul>
<p><img src="/2018/09/25/垃圾回收机制/ref_count2.png" alt="imag"></p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>在复制算法中，先将内存分为两个部分，From 区和 To 区，两部分大小相等。对象分配时，只会在 From 区进行分配。复制算法可以分两步，第一步为类似标记清除算法的标记，在 From 区中，找出所有活动的对象。区别在于第二步。复制算法会把这些活动的对象，复制到 To 区中，再将原有的 From 区全部清空，并交换两部分内存的职责，即一次 GC 后，原有的 From 区会成为 To 区，To 区相反。</p>
<p><img src="/2018/09/25/垃圾回收机制/copy.png" alt="imag"></p>
<p>优点<br>复制算法的优点相比于另外两个算法还是多一些的：</p>
<p>效率快：相比于标记清除算法，复制算法在标记阶段，只需要标记哪些对象是活动的就可以了，相比于标记清除算法需要遍历所有的对象，性能上有提升不会发生碎片化：同样相比于标记清除算法，由于存活下来的对象会在 To 区中连续的分配，因此不会像标记清除算法那样，需要维护碎片空间分配速度快：由于不会发生碎片化，如果有一个新的对象请求内存，那么分配时可以直接追加在 From 区已用内存之后，分配的速度快.</p>
<p>缺点<br>同样复制算法也不是十全十美，它也有着如下的缺点：内存使用率低：由于复制算法把内存分成了两块，那么对于对象的可用空间来说，仅仅是其他算法的一半自对象的递归复制：一个对象通常会关联一些自对象。在复制这些对象的时候，还需要递归的去处理它的自对象，这通常会产生一定的开销。同时，在递归调用时，存在着函数栈的消耗，潜藏着栈溢出的风险</p>
<h4 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h4><ul>
<li>不可到达对象在内存中是分散的，回收对象后，空闲内存是分段的</li>
<li>移动可到达的堆对象，保持内存连续<br><img src="/2018/09/25/垃圾回收机制/relocate.png" alt="imag"></li>
</ul>
<h4 id="分代算法"><a href="#分代算法" class="headerlink" title="分代算法"></a>分代算法</h4><ul>
<li>销毁的总是年轻的对象<br>— 统计表明：80%-90%新分配的对象会在随后几百万条指令周期内销毁</li>
<li>将堆空间分成几块</li>
<li>新对象生成在空间1</li>
<li>当空间1满了，将对象移动到空间2，再往上也如此类推</li>
<li>空间序号越小，垃圾回收检测越频繁</li>
<li>Python分为三代，gc.get_threshold可以获取每一代空间的默认阈值</li>
</ul>
<h3 id="各语言的垃圾回收策略"><a href="#各语言的垃圾回收策略" class="headerlink" title="各语言的垃圾回收策略"></a>各语言的垃圾回收策略</h3><table>
<thead>
<tr>
<th>Luanguage</th>
<th>引用计数</th>
<th>标记-清除</th>
<th>分代</th>
<th>重定位</th>
<th>复制</th>
</tr>
</thead>
<tbody>
<tr>
<td>Python</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>JavaScript</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Java</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
</tr>
<tr>
<td>Golang</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>1、JavaScript 中 BOM、COM 用的是引用计数机制<br><br>2、Golang 最新用的是三色标记-清除算法，标记阶段需要 STW，清除阶段可以并发进行</p>
</blockquote>
<h3 id="Python垃圾回收实战"><a href="#Python垃圾回收实战" class="headerlink" title="Python垃圾回收实战"></a>Python垃圾回收实战</h3><p>以 Python 为例 Python 的 gc.collect() 标记-清除需要消耗一定时间，在对象数量达到百万级别时会有秒级卡顿。有些项目对实时性要求比较高，会调用 gc.disable()关闭 gc；关闭 gc 意味着在开发阶段就要解除所有的循环引用，不然会造成内存泄漏。即使不关闭 gc，在销毁对象时解除循环引用，有利于减少 gc 卡顿时间。那如何找到循环引用的对象？如何找出引用环的情况？</p>
<blockquote>
<p>gc.DEBUG_SAVEALL When set, all unreachable objects found will be appended to garbage rather than being freed. This can be useful for debugging a leaking program.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gc.set_debug(gc.DEBUG_SAVEALL)</span><br><span class="line">gc.collect()</span><br><span class="line">print(gc.garbage)</span><br></pre></td></tr></table></figure>
<p>上面的方法可以找到垃圾对象，但要靠自己去找到对象间的引用情况来解除引用。利用 objgraph 可以找到对象的引用关系链并生成图。但是在实践中，进程中对象数量较大时，objgraph 经常会慢到让人想要原地自爆。也可以自己编写工具，在 gc.garbage 做图的遍历，找到所有的环引用，这样会比较全比较快。(TODO: 待分享通过gc.garbage查环工具代码)<br><img src="/2018/09/25/垃圾回收机制/obj_graph.png" alt="imag"></p>
<blockquote>
<p>gc.garbage <br><br>A list of objects which the collector found to be unreachable but could not be freed (uncollectable objects). By default, this list contains only objects with <strong>del</strong>() methods. [1] Objects that have <strong>del</strong>() methods and are part of a reference cycle cause the entire reference cycle to be uncollectable, including objects not necessarily in the cycle but reachable only from it. Python doesn’t collect such cycles automatically because, in general, it isn’t possible for Python to guess a safe order in which to run the <strong>del</strong>() methods. If you know a safe order, you can force the issue by examining the garbage list, and explicitly breaking cycles due to your objects within the list. Note that these objects are kept alive even so by virtue of being in the garbage list, so they should be removed from garbage too. For example, after breaking cycles, do del gc.garbage[:] to empty the list. It’s generally better to avoid the issue by not creating cycles containing objects with <strong>del</strong>() methods, and garbage can be examined in that case to verify that no such cycles are being created.</p>
</blockquote>
<blockquote>
<p>If DEBUG_SAVEALL is set, then all unreachable objects will be added to this list rather than freed.</p>
</blockquote>
<p>有个很重要的点，Python2 中，当对象形成环引用，即使开启 gc，实现了<strong>del</strong>方法的对象也无法被回收，因为 gc 并不知道在<strong>del</strong>方法中是否对引用的对象有操作，无法确定正确的回收顺序。在Python 中，一般而言，尽量不要实现<strong>del</strong>方法，而改用其他方法在销毁时手动调用之。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://liangiter.top/2018/09/21/通用技术总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiangIter">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/21/通用技术总结/" itemprop="url">通用技术总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-21T15:51:30+08:00">
                2018-09-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>选择一门技术，要综合考量技术的多个方面来评估。大方向上首先考虑<code>技术综合面</code>：</p>
<ol>
<li>业界是否有知名的成功案例；</li>
<li>是否有强大后援；</li>
<li>是否有活跃的开发者论坛；</li>
</ol>
<p>业界有知名成功案例意味着该技术通过了技术人员的考究，经过了工程的检验，坑也会相对较少。<br>比如Java有Sun，Golang有Google，有这些实力雄厚的公司或机构做背书，有理由相信这些技术未来的潜力；<br>java、python有活跃的论坛，有丰富开源库，做网络应用、缓存、爬虫等工作都有现成的库，无需造轮，大大提高开发效率。另外，有活跃的开发者论坛意味着技术资料比较丰富，并且绝大部分你遇到的问题都有前人遇到过，可以大大减少爬坑的时间。</p>
<p>业务需求会对系统有一些要求，根据业务特点考虑以下问题：</p>
<ol>
<li>计算密集型、IO密集型：计算密集型与IO密集型的任务会对系统有不同的要求；计算密集型任务可以考虑编译型语言、多核&amp;多机（分布式）来实现。多核IO密集型任务并没有什么帮助，多路复用会有好的效果。</li>
<li>读写频率：不同的读写频率有不同适用的数据结构和算法，会衍生出不同的系统架构；</li>
<li>系统实时性要求：实时性要求高的系统需要快速响应，服务线程需要避免长时间堵塞式的调用，可以利用并行、分时、多路复用等特性；</li>
<li>系统安全性要求：服务器连续运行时间要求、数据一致性要求，分布式系统需要考虑CAP问题；</li>
<li>热更新、热部署：在虚拟机中运行的脚本语言更适合热部署；</li>
<li>平衡开发效率与运行效率：一般而言抽象层次较高的脚本语言开发效率较高，但运行效率较差；封装程度较低的编译型语言运行效率较高，但开发效率较差；</li>
<li><code>技术综合面</code>：参考本文前面的对<code>技术综合面</code>的说明；</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://liangiter.top/2018/09/21/全球同服游戏服务器框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiangIter">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/21/全球同服游戏服务器框架/" itemprop="url">游戏全球同服服务器框架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-21T15:40:02+08:00">
                2018-09-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>背景：</p>
<blockquote>
<p>最近公司要开发一款全球同服，所有玩家可相互匹配战斗、相互加好友、相互聊天的游戏</p>
</blockquote>
<hr>
<p>服务器需要面临的需求有：</p>
<ul>
<li>玩家注册量要支持十亿量级</li>
<li>玩家在线量要支持千万到亿量级</li>
<li>所有在线玩家可相互通信</li>
<li>十亿级别玩家名模糊搜索</li>
</ul>
<p>需要支持如此量级的连接，必须要消除服务器进程的单点问题，玩家客户端能够均匀的连接到各个服务器进程上。<br>如果玩家可动态选择连接的进程，轻则面临rpc没有命中、重则引发数据回档问题。玩家根据一定的规则均匀Hash到服务器各个进程中，玩家对应的进程固定，不用担心rpc命中和数据存盘的时序问题。</p>
<p>对于各种服务，类似好友、战斗匹配而言，都不能出现单点。每种服务都是由多进程协同组成功能集群，功能集群对外提供高并发服务。集群服务进程可以用一致性hash规则来选择。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://liangiter.top/2018/09/21/Python内存泄露查询/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiangIter">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/21/Python内存泄露查询/" itemprop="url">Python内存泄露查询</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-21T15:40:02+08:00">
                2018-09-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">需求背景</span><br><span class="line">最近项目在压力测试期间，进程在运行中内存持续增加，物理内存很快就被消耗殆尽。为了服务器能持久提供服务，需要对内存进行诊断。</span><br><span class="line">本文讨论Python层内存对象的检查，CPython扩展产生的泄露不在本文讨论范围。</span><br></pre></td></tr></table></figure>
<p>Python垃圾回收机制背景：</p>
<p>Python利用引用计数进行垃圾回收，当引用为0时，对象会被虚拟机析构内存会被释放。环引用则需要通过 <strong>标记-清除算法</strong>(<code>Mark-Sweep</code>) 来销毁对象。如果对象实现了<strong>del</strong>方法，由于gc无法断定销毁是否会影响<strong>del</strong>的调用，故gc无法处理此类对象而产生垃圾。</p>
<h4 id="需要处理的异常情况包括："><a href="#需要处理的异常情况包括：" class="headerlink" title="需要处理的异常情况包括："></a>需要处理的异常情况包括：</h4><ul>
<li><strong>垃圾对象</strong>：gc概念上的垃圾对象</li>
<li><strong>泄露对象</strong>：对象在逻辑上应该被销毁，但是有外部引用，导致对象没有销毁</li>
<li><strong>环引用对象</strong>：环引用对象会增加gc的cpu消耗，会延长对象回收时间</li>
</ul>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ol>
<li>垃圾对象处理：Python类尽量不要实现<strong>del</strong>方法，用其他机制实现就能避免垃圾对象。</li>
<li>泄露对象解决：需要对逻辑层面十分了解，能知道如何判断一个对象是否是为逻辑层面应该销毁的对象。一般而言，对象用一个属性来标识是否已销毁，利用<code>gc.getobject</code>遍历对象全集，通过标识进行判断就能找出不正常的对象。利用<code>objgraph.show_chain(objgraph.find_backref_chain(obj, objgraph.is_proper_module))</code>生成引用链，解除异常引用解决问题。</li>
<li>环引用对象处理：先<code>gc.set_debug(gc.DEBUG_SAVEALL)</code>，然后<code>gc.collect()</code>，再通过对<code>gc.garbage</code>里的对象利用引用关系进<em>DFS</em>遍历，记录所有找到的环。对记录的环引用中的对象，在销毁的时候解除引用即可。</li>
</ol>
<h4 id="最后分享Python几个常用的内存调试工具："><a href="#最后分享Python几个常用的内存调试工具：" class="headerlink" title="最后分享Python几个常用的内存调试工具："></a>最后分享Python几个常用的内存调试工具：</h4><ul>
<li><p><a href="https://pypi.python.org/pypi/memory-tools/1.0.5" target="_blank" rel="noopener">memory-tools</a>模块，summarize_objects()可以统计内存中各个class实例数量和所占内存量，并排序输出。可以通过查看对象数量和内存量来分析异常情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Objects count 3,790</span><br><span class="line">Objects size 833,344</span><br><span class="line"></span><br><span class="line">      Size Count Type</span><br><span class="line">   476,864   296 &lt;type &apos;dict&apos;&gt;</span><br><span class="line">    76,320   954 &lt;type &apos;wrapper_descriptor&apos;&gt;</span><br><span class="line">    64,920   541 &lt;type &apos;function&apos;&gt;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">Count       Size Type</span><br><span class="line">  954     76,320 &lt;type &apos;wrapper_descriptor&apos;&gt;</span><br><span class="line">  541     64,920 &lt;type &apos;function&apos;&gt;</span><br><span class="line">  515     37,080 &lt;type &apos;builtin_function_or_method&apos;&gt;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://pypi.python.org/pypi/objgraph/3.1.2" target="_blank" rel="noopener">objgraph</a>模块，可以统计类型对应实例数量，统计类型增长情况，获得指定类型所有实例，<strong>获得指定对象的引用链</strong><img src="/2018/09/21/Python内存泄露查询/objgraph.png" alt="imag"></p>
</li>
<li><p><a href="https://pypi.python.org/pypi/memory_profiler/0.50.0" target="_blank" rel="noopener">memory_profiler</a>可对Python代码逐行显示Mem增量，便于发现内存消耗高的代码块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Line #    Mem usage  Increment   Line Contents</span><br><span class="line">==============================================</span><br><span class="line">     3                           @profile</span><br><span class="line">     4      5.97 MB    0.00 MB   def my_func():</span><br><span class="line">     5     13.61 MB    7.64 MB       a = [1] * (10 ** 6)</span><br><span class="line">     6    166.20 MB  152.59 MB       b = [2] * (2 * 10 ** 7)</span><br><span class="line">     7     13.61 MB -152.59 MB       del b</span><br><span class="line">     8     13.61 MB    0.00 MB       return a</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html" target="_blank" rel="noopener">TCMalloc</a><br>Google内存工具，利用tcmalloc 来代替malloc calloc new等等，这样Google Heap Profiler就能知道内存的分配情况，从而分析出内存问题。这种机制可以监测所有程序语言的内存分配情况来分析内存问题。<br>TCMalloc也包括一个堆检查器 和堆分析器。<br><br><a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html" target="_blank" rel="noopener">官网</a><br><br><a href="http://www.cnblogs.com/my_life/articles/4661790.html" target="_blank" rel="noopener">安装</a><br><br><a href="http://blog.csdn.net/jhzhou/article/details/7245992" target="_blank" rel="noopener">使用</a></p>
</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://yyc.solvcon.net/writing/2015/pymem_survey.html" target="_blank" rel="noopener">Python内存分析工具文章链接</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://liangiter.top/2018/09/21/PythonCPU诊断优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiangIter">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/21/PythonCPU诊断优化/" itemprop="url">PythonCPU诊断优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-21T15:40:02+08:00">
                2018-09-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>无论用什么语言来实现需求，最后基本都会需要对代码运行时间进行优化，降低cpu占用率</p>
</blockquote>
<p>这里主要介绍两个profile工具：</p>
<ol>
<li>cProfile：用cProfile生成程序运行时的profile文件，用<code>python pyprof2calltree.py -i file</code>生成文件供QCacheGrind读取；然后用qcachegrind.exe查看，可以看到图像化的代码情况，面积表示cpu占比，可以很方便的找到cpu占比高的代码来进行优化。</li>
<li>vmprof：vmprof支持pypy，先用vmprof生成profile文件（<code>pypy -m vmprof -o log.jit example.py</code>），用<code>vmprofshow log.jit</code>来查看代码占用cpu情况；</li>
</ol>
<p>cprofile图形化结果更加强大，但是不支持pypy。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://liangiter.top/2018/09/21/pomelo压测/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiangIter">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/21/pomelo压测/" itemprop="url">Pomelo压测.md</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-21T15:40:02+08:00">
                2018-09-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://liangiter.top/2018/09/21/十亿级别字符串模糊匹配设计与实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiangIter">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/21/十亿级别字符串模糊匹配设计与实现/" itemprop="url">十亿级别字符串模糊匹配设计与实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-21T15:40:02+08:00">
                2018-09-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>项目用mongodb作为数据库，mongodb支持索引，可对玩家名建立索引快速查找玩家名对应的项。模糊匹配方面，mongodb有提供全文匹配机制，可以用来实现模糊匹配需求。不过mongodb的全文匹配有两个缺点，一是中文版的全文匹配是收费功能，二是mongodb的全文匹配专业性、速度性都不是很成熟。使得项目不得不另外寻找新的实现方式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ID = <span class="string">"59e1e6cd5c21ac436052300c"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Name = <span class="string">"玩家名字长度八字"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> sys.getsizeof(Name), sys.getsizeof(ID)</span><br><span class="line"></span><br><span class="line">(<span class="number">49</span>, <span class="number">57</span>)</span><br></pre></td></tr></table></figure>
<p>考虑利用游戏脚本逻辑来实现，用Python多进程协同组成集群方式来实现。这种方式自由度高、易维护、可控性强，在游戏服务器架构上无需要额外部署新的环境等诸多优点。元数据<code>玩家名， 玩家ID</code>在Python中所占内存约为110Byte，加上建立索引的消耗共占内存约200Byte，十亿玩家的数据量就是200GB。考虑到Python内存利用率低，群集内存消耗过大而放弃用Python脚本逻辑来实现。最后考虑用基于Lucene的全文搜索引擎Elasticsearch来实现这个功能。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://liangiter.top/2018/09/21/Golang性能测试与评价/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiangIter">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/21/Golang性能测试与评价/" itemprop="url">Golang性能测试与思考</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-21T10:18:23+08:00">
                2018-09-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文测试Go、Python、PyPy、C的效率，作为学习Go的参考标准。测试用例：进行(2&lt;&lt;25)次简单加法</p>
<blockquote>
<p>测试环境：<br><br>系统：Windows7 专业版<br><br>CPU：Intel(R) Core(TM) i5-4590 CPU @ 3.30GHZ 3.30GHZ, 14级流水线（Pipeline）<br> </p>
</blockquote>
<p>参考资料：<br><a href="https://zh.wikipedia.org/wiki/Core%E5%BE%AE%E6%9E%B6%E6%A7%8B" target="_blank" rel="noopener">Core微架构14级流水线</a></p>
<p>测试用例：进行(2&lt;&lt;25)次简单加法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang example</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> N <span class="keyword">int</span> = <span class="number">2</span> &lt;&lt; <span class="number">25</span></span><br><span class="line">    <span class="keyword">var</span> j <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    t0 := time.Now()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; (N); i++ &#123;</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    elapsed := time.Since(t0)</span><br><span class="line">    fmt.Println(<span class="string">"N:"</span>, N, <span class="string">"time:"</span>, elapsed)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：N: 67108864 time: 20.5027ms</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># Python and Pypy example</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">t0 = time.clock()</span><br><span class="line"></span><br><span class="line">N = <span class="number">2</span> &lt;&lt; <span class="number">25</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(N):</span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"N:&#123;&#125;, time:&#123;:.2f&#125;ms"</span>.format(N, (time.clock() - t0) * <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<p>测试结果：<br><br>Python N:67108864, time:5102.14ms<br><br>PyPy: N:67108864, time:124.16ms</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test1.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/timeb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined __linux__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">ClockMs64</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">timeb64</span> <span class="title">timebuffer</span>;</span></span><br><span class="line">    _ftime64_s(&amp;timebuffer);</span><br><span class="line">    <span class="keyword">return</span> timebuffer.time * <span class="number">1000</span> + timebuffer.millitm;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    timespec ts;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == clock_gettime(CLOCK_REALTIME, &amp;ts))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)ts.tv_sec) * <span class="number">1000</span> + ts.tv_nsec/<span class="number">1000000</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">Clock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>)ClockMs64();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    UINT64 N =  <span class="number">2</span> &lt;&lt; <span class="number">25</span>;</span><br><span class="line">    UINT64 j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> start = Clock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(UINT64 i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        j += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> end = Clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"N:%I64d, time:%dms\n"</span>, N, end-start);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：N:67108864, time:160ms</p>
<p>综合以上测试结果：<br></p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">C</td>
<td style="text-align:left">160ms</td>
</tr>
<tr>
<td style="text-align:left">PyPy</td>
<td style="text-align:left">124.16ms</td>
</tr>
<tr>
<td style="text-align:left">Python</td>
<td style="text-align:left">5102.14ms</td>
</tr>
<tr>
<td style="text-align:left">Golang</td>
<td style="text-align:left">20.50ms</td>
</tr>
</tbody>
</table>
<p>结论：从测试结果来看，执行效率Golang &gt; PyPy &gt; C &gt; Python <br><br>分析：<br><br>Golang是编译型语言，会将代码编译成二进制可执行机器码。我们来分析执行Golang的执行时间，我们知道一个汇编指令至少执行一个CPU周期（指令执行整数个周期，大部分指令执行一个周期，指令具体执行周期可以参考CPU手册）。也就是说只要我们知道执行整个程序的汇编指令数量，我们就能对程序运行时间做出评判。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">测试用例循环体内执行以下操作，大致翻译成汇编指令，统计汇编指令数目</span><br><span class="line">1. i &lt; N --&gt; 将i、N入栈，cmp后比较结果来做Jmp操作，大约5条汇编指令；</span><br><span class="line">2. j += 1 --&gt; 将j入栈，执行Inc操作，然后保存到j，大约3条汇编指令；</span><br><span class="line">3. i ++ --&gt; 将i入栈，执行Inc，保存到i，大约3条汇编；</span><br><span class="line">4. 还有一个隐藏的Jump到操作1的操作， 1条汇编</span><br><span class="line"></span><br><span class="line">故一个循环体总体汇编指令条目为(5+3+3+1)=12条</span><br></pre></td></tr></table></figure></p>
<p>CPU主频为3.30GHZ，循环体汇编条目约为12条。我们以CPU满载、每条指令一个周期计算，执行<code>2&lt;&lt;25</code>次循环体需要用时=1000 <em> ((2&lt;&lt;25) </em> 12) / (3.3 * (10**9)) = 244.03ms。<br>而我们测试Golang用时20.50ms，为什么Golang比前面计算的244.03ms远远要小？秘密在于CPU的指令流水线，根据资料我们知道Intel CPU是14级流水线架构，也就是说一个CPU周期最大可执行14条汇编指令。我们用单级流水线理论时间除以Golang用时：244.03ms / 20.50ms = 11.9，考虑多CPU周期汇编指令的存在和系统调度消耗，14是我们理论上限值，可见结果符合预期。</p>
<p>Golang在这个测试用例中比C语言更快，更是秒杀Python，超乎预期。通过计算发现Golang的计算效率接近CPU的极限，着实是一门高效的编译型语言。</p>
<p>另外，附上常见的Benchmark连接<a href="http://benchmarksgame.alioth.debian.org/u64q/task-descriptions.html" target="_blank" rel="noopener">The Computer Language<br>Benchmarks Game</a>，可对比各种语言的性能情况</p>
<p>参考资料：<br><br><a href="https://zh.wikipedia.org/wiki/Core%E5%BE%AE%E6%9E%B6%E6%A7%8B" target="_blank" rel="noopener">Core微架构-14级流水线</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Liang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="http://liangiter.top" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:hl_hnu@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liang</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
