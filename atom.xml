<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LiangIter</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liangiter.top/"/>
  <updated>2018-11-10T07:44:03.859Z</updated>
  <id>http://liangiter.top/</id>
  
  <author>
    <name>Liang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>电影推荐</title>
    <link href="http://liangiter.top/2018/11/10/%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90/"/>
    <id>http://liangiter.top/2018/11/10/电影推荐/</id>
    <published>2018-11-10T07:18:48.000Z</published>
    <updated>2018-11-10T07:44:03.859Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>背景：最近公司要我们每人推荐一部电影，给公司所有人</p></blockquote><p>思来想去，电影看过不少，有创意、有思想、引人深思的电影不多，尤其还与程序员相关的，我首先想起了早年看到的《异次元骇客》。电影讲述一个计算机模拟的虚拟世界中与现实中的其设计者真实世界的交叉，一层一层的解密，真到最后真相大白，令人惊讶。<br><br>看完电影不禁想起一个问题：我是谁，我从何而来，我为什么会存在于这个世界？我们的生活是真实的还是被更高阶智能虚拟出来的呢？<br><br>意大利罗马市政府曾颁布一项奇特的条例，禁止市民用球形的鱼缸养金鱼，理由是，球形鱼缸会混淆鱼的视觉，会扭曲它们对真实世界的观察。但进一步讲，我们人类是否被更高阶智能养在叫做“宇宙”的容器内呢。金鱼在鱼缸中总结出来的鱼缸物理学能算作正确的物理学吗？我们所在的世界是三维的吗，虫洞又是怎么回事？人类对世界的了解，能真正反映真实的世界吗？<br><br>这让我想起霍金在《大设计》，书中讨论生命的来源是否需要上帝的参与，这反映了科学家对人类来源的做出的思考，其中很多观点令人眼界大开。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;背景：最近公司要我们每人推荐一部电影，给公司所有人&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;思来想去，电影看过不少，有创意、有思想、引人深思的电影不多，尤其还与程序员相关的，我首先想起了早年看到的《异次元骇客》。电影讲述一个计算机模拟的虚拟世界中
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Elasticsearch+Kibana</title>
    <link href="http://liangiter.top/2018/10/30/Elasticsearch-Kibana/"/>
    <id>http://liangiter.top/2018/10/30/Elasticsearch-Kibana/</id>
    <published>2018-10-30T09:36:05.000Z</published>
    <updated>2018-11-10T07:17:47.775Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上篇文章介绍了介绍了Fluentd以及EFK机制，最近了解了Elasticsearch，在这里做一个总结</p></blockquote><blockquote><p>Elasticsearch is a search engine based on Lucene. It provides a distributed, multitenant-capable full-text search engine with an HTTP web interface and schema-free JSON documents. Elasticsearch is developed in Java and is released as open source under the terms of the Apache License. Official clients are available in Java, .NET (C#), PHP, Python, Apache Groovy, Ruby and many other languages. According to the DB-Engines ranking, Elasticsearch is the most popular enterprise search engine followed by Apache Solr, also based on Lucene.<br><br><br>Elasticsearch是一个基于Lucene的搜索引擎。它提供了一个分布式、多用户全文搜索引擎，有着HTTP Web界面和无结构JSON文档。Elasticsearch是用Java开发的，并根据Apache License的条款作为开源发布。官方客户端有Java，.NET（C＃），PHP，Python，Apache Groovy，Ruby和许多其他语言版本。根据DB-Engines排名，Elasticsearch是最受欢迎的企业搜索引擎，后面是基于Lucene的Apache Solr。——摘自维基百科</p></blockquote><p>什么是全文搜索？全文检索是指计算机索引程序通过扫描文章中的每一个词，对每一个词建立一个索引，根据索引可以找到文档。我们使用的百度、谷歌等搜索引擎，就是基于这个技术对所有爬取的万维网网页做拆分建立建立全文索引，当我们输入关键字时给我们展现相关的页面。当然，商业搜索引擎还采用竞价排名、PageRank等复杂的算法。</p><p>Elasticsearch是基于开源库Lucene的封装，Lucenej接口使用较为复杂，Elasticsearch使用会更加简单。要明白Elasticsearch机制，首先得搞清楚Lucene是什么。</p><blockquote><p>Lucene是apache软件基金会4 jakarta项目组的一个子项目，是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎（英文与德文两种西方语言）。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎。 ——摘自百度百科</p></blockquote><p>Lucene全词匹配索引的关键技术是用到了FST(Finite State Transducer)——有穷状态转换器。在自然语言处理等领域有很大应用，其功能类似于字典的功能（STL 中的map，C# 中的Dictionary），但其查找是O（1）的，仅仅等于所查找的key长度。目前Lucene4.0在查找Term时就用到了该算法来确定此Term在字典中的位置。<br>关于FST的介绍，可以看这篇博文<a href="https://blog.csdn.net/J_bean/article/details/78660252" target="_blank" rel="noopener">lucene源代码学习之FST(Finite State Transducer)在SynonymFilter中的实现思想</a></p><h3 id="Kibana使用"><a href="#Kibana使用" class="headerlink" title="Kibana使用"></a>Kibana使用</h3><p><img src="/2018/10/30/Elasticsearch-Kibana/kibana.jpg" alt="kibana"><br><img src="/2018/10/30/Elasticsearch-Kibana/kibana2.png" alt="kibana"><br>搜索102246，页面呈现包含搜索字段结果，上方还有以时间为横坐标、log条目为纵坐标的柱状图。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;上篇文章介绍了介绍了Fluentd以及EFK机制，最近了解了Elasticsearch，在这里做一个总结&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Elasticsearch is a search engine base
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Fluentd简介</title>
    <link href="http://liangiter.top/2018/10/18/Fluentd%E7%AE%80%E4%BB%8B/"/>
    <id>http://liangiter.top/2018/10/18/Fluentd简介/</id>
    <published>2018-10-18T01:12:03.000Z</published>
    <updated>2018-10-19T02:25:32.672Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近公司想要统一管理各个项目的日志，也为以后日志可视化查询做一个铺垫。经过筛选，选择了fluentd来做日志的收集转发工作，预想利用EFK来做日志收集、查询、可视化的方案。<br><br>啥？你问我为啥不用Logstash，可参考文章<a href="https://logz.io/blog/fluentd-logstash/" target="_blank" rel="noopener">Fluentd vs. Logstash: A Comparison of Log Collectors</a><br>,两者差异并不大，Fluentd所占内存较小、社区更活跃。</p></blockquote><h3 id="Fluentd是什么？能解决什么问题？"><a href="#Fluentd是什么？能解决什么问题？" class="headerlink" title="Fluentd是什么？能解决什么问题？"></a>Fluentd是什么？能解决什么问题？</h3><p><a href="https://www.fluentd.org/" target="_blank" rel="noopener">官网简介</a>： Fluentd是一个用于统一日志层的开源数据收集器。Fluentd允许您统一数据收集和使用，以便更好地使用和理解数据。Fluentd是云端原生计算基金会(CNCF)的成员项目之一，遵循Apache 2 License协议<br><br>这我们应用中，Fluentd负责从游戏服务器收集日志信息，将数据流交给后续数据存盘、查询工具。换句话说，Fluentd不负责生产数据、不负责存储数据，只是数据的搬运工。</p><ul><li><strong>使用JSON进行统一日志记录</strong>：Fluentd尝试尽可能地将数据结构化为JSON：这允许Fluentd 统一处理日志数据的所有方面：收集，过滤，缓冲和跨多个源和目标（统一日志层）输出日志。使用JSON可以更轻松地进行下游数据处理，因为它具有足够的结构，可以在保留灵活模式的同时进行访问。</li><li><strong>可插拔架构</strong>：Fluentd拥有灵活的插件系统，允许社区扩展其功能。我们的500多个社区贡献插件连接了数十个数据源和数据输出。通过利用插件，您可以立即开始更好地使用日志。</li><li><strong>所需的资源较少</strong>： Fluentd是用C语言和Ruby组合编写的，只需要很少的系统资源。vanilla实例运行30-40MB内存，可处理13,000个事件/秒/核心。</li><li><strong>内置可靠性</strong>：Fluentd支持基于内存和文件的缓冲，以防止节点间数据丢失。Fluentd还支持强大的故障转移功能，可以设置为高可用性。</li></ul><p>注：<a href="https://github.com/fluent/fluentd-benchmark/tree/master/one_forward" target="_blank" rel="noopener">fluentd-benchmark</a> 对简单数据<code>2014-02-20 17:20:55 +0900 [info]: plugin:out_flowcounter_simple count:500       indicator:num   unit:second</code>测压结果是157148次/s</p><p><img src="/2018/10/18/Fluentd简介/fluentd_1.jpg" alt="fluentd log"><br>Fluentd解决数据流流向混乱的问题，通过在两者之间提供统一的日志记录层，从后端系统中分离数据源。</p><h3 id="为什么要用Fluentd？"><a href="#为什么要用Fluentd？" class="headerlink" title="为什么要用Fluentd？"></a>为什么要用Fluentd？</h3><ul><li>简单易用且灵活</li><li>开源</li><li>久经考验的可靠性和性能：5,000多家数据驱动型公司依靠Fluentd通过更好地使用和了解他们的日志数据来区分他们的产品和服务。</li><li><a href="https://www.fluentd.org/community" target="_blank" rel="noopener">活跃的社区</a></li><li>与Logstash相比占用内存更少、社区更活跃，两者比较可参考<a href="https://logz.io/blog/fluentd-logstash/" target="_blank" rel="noopener">Fluentd vs. Logstash: A Comparison of Log Collectors</a></li></ul><p>人气情况：</p><ul><li>github fluent/fluentd start 6.8k</li><li>npm fluent-logger weekly downloads 11,493</li></ul><h3 id="Fluentd的用户："><a href="#Fluentd的用户：" class="headerlink" title="Fluentd的用户："></a>Fluentd的用户：</h3><ul><li>Atlassian</li><li>Microsoft</li><li>amazon</li><li>LINE</li><li>PPTV</li><li>…</li></ul><h4 id="fluentd安装"><a href="#fluentd安装" class="headerlink" title="fluentd安装"></a>fluentd安装</h4><p>fluentd安装、启动可参考<a href="https://docs.fluentd.org/v1.0/articles/quickstart" target="_blank" rel="noopener">Fluent doc</a></p><h4 id="Fluentd配置"><a href="#Fluentd配置" class="headerlink" title="Fluentd配置"></a>Fluentd配置</h4><ul><li>source: 数据源配置，可接受log-tail、http、tcp、udp等方式数据，</li><li>filter: 数据过滤配置，对匹配的tag进行过滤</li><li>match: 数据输出配置，对匹配的tag进行输出设置</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">source</span>&gt;</span><br><span class="line">  @<span class="built_in">type</span> tcp</span><br><span class="line">  tag tcp.events <span class="comment"># required</span></span><br><span class="line">  &lt;parse&gt;</span><br><span class="line">    @<span class="built_in">type</span> regexp</span><br><span class="line">    expression /^(?&lt;field1&gt;\d+):(?&lt;field2&gt;\w+)$/</span><br><span class="line">  &lt;/parse&gt;</span><br><span class="line">  port 5170   <span class="comment"># optional. 5170 by default</span></span><br><span class="line">  <span class="built_in">bind</span> 0.0.0.0 <span class="comment"># optional. 0.0.0.0 by default</span></span><br><span class="line">  delimiter \n <span class="comment"># optional. \n (newline) by default</span></span><br><span class="line">&lt;/<span class="built_in">source</span>&gt;</span><br></pre></td></tr></table></figure><p>Example input:<br><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'123456:awesome'</span> | netcat 0.0.0.0 5170</span><br></pre></td></tr></table></figure></p><p>Parsed result like below:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"field1"</span>:<span class="string">"123456"</span>,<span class="string">"field2"</span>:<span class="string">"awesome&#125;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## built-in TCP input</span></span><br><span class="line"><span class="comment">## @see http://docs.fluentd.org/articles/in_forward</span></span><br><span class="line">&lt;<span class="built_in">source</span>&gt;</span><br><span class="line">  @<span class="built_in">type</span> forward</span><br><span class="line">  @id input_forward</span><br><span class="line">  &lt;security&gt;</span><br><span class="line">    self_hostname input.local</span><br><span class="line">    shared_key liang_handsome</span><br><span class="line">  &lt;/security&gt;</span><br><span class="line">&lt;/<span class="built_in">source</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter example.*.*&gt;</span><br><span class="line">  @<span class="built_in">type</span> grep</span><br><span class="line">  regexp1 levelStr (INFO|WARN|ERROR)</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Match events tagged with "myapp.access" and</span></span><br><span class="line"><span class="comment"># store them to /var/log/fluent/access.%Y-%m-%d</span></span><br><span class="line"><span class="comment"># Of course, you can control how you partition your data</span></span><br><span class="line"><span class="comment"># with the time_slice_format option.</span></span><br><span class="line">&lt;match example.*.*&gt;</span><br><span class="line">  @<span class="built_in">type</span> file</span><br><span class="line">  path E:\software\fluentd\td-agent\<span class="built_in">log</span>\output_file</span><br><span class="line">&lt;/match&gt;</span><br></pre></td></tr></table></figure><p><code>fluentd更多配置请参考官网:https://docs.fluentd.org/v1.0/articles/config-file</code></p><h3 id="fluent-logger配置"><a href="#fluent-logger配置" class="headerlink" title="fluent-logger配置"></a>fluent-logger配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;configure, getLogger, shutdown&#125; <span class="keyword">from</span> <span class="string">'log4js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fluentAppender = configure(&#123;</span><br><span class="line">  appenders: &#123;</span><br><span class="line">    <span class="string">"fluent"</span>: &#123;</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"log4js-fluent-appender"</span>,</span><br><span class="line">      <span class="string">"tag_prefix"</span>: <span class="string">"example.your_keys"</span>,</span><br><span class="line">      <span class="string">"options"</span>: &#123;</span><br><span class="line">        <span class="string">"levelTag"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"host"</span>: <span class="string">"localhost"</span>,</span><br><span class="line">        <span class="string">"port"</span>: <span class="number">24224</span>,</span><br><span class="line">        <span class="string">"timeout"</span>: <span class="number">3.0</span>,</span><br><span class="line">        <span class="string">"reconnectInterval"</span>: <span class="number">600000</span>,</span><br><span class="line">        <span class="string">"security"</span>: &#123;</span><br><span class="line">          <span class="string">"clientHostname"</span>: <span class="string">"client"</span>,</span><br><span class="line">          <span class="string">"sharedKey"</span>: <span class="string">"liang_handsome"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  categories: &#123;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      appenders: [<span class="string">'fluent'</span>],</span><br><span class="line">      level: <span class="string">'info'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如上配置，fluent-logger根据host、port连接fluentd，sharedKey作为连接认证</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.info(&#123;<span class="attr">log_type</span>: <span class="string">"create-room"</span>, <span class="attr">uuid</span>: <span class="number">1112</span>, <span class="attr">room_id</span>: <span class="number">234</span>, <span class="attr">config</span>: &#123;<span class="attr">cards</span>: <span class="number">16</span>, <span class="attr">chairs</span>: <span class="number">3</span>&#125;&#125;);</span><br></pre></td></tr></table></figure><p>fluentd输出为:<br><br><code>2018-10-18T10:50:38+08:00    example.your_keys.INFO    {&quot;timestamp&quot;:1539831038583.0,&quot;category&quot;:&quot;default&quot;,&quot;levelInt&quot;:20000,&quot;levelStr&quot;:&quot;INFO&quot;,&quot;context&quot;:{},&quot;data&quot;:&quot;log { log_type: &#39;create-room&#39;, uuid: 1112, room_id: 234 }&quot;}</code></p><h3 id="JavaScript-fluent-logger缓存测试："><a href="#JavaScript-fluent-logger缓存测试：" class="headerlink" title="JavaScript fluent_logger缓存测试："></a>JavaScript fluent_logger缓存测试：</h3><ul><li>在fluentd关闭的情况下，logger输出20条日志，开启fluentd，fluent-logger会自动连接上fluentd，并将缓存的20条log发送至fluentd</li><li>正常连接fluentd，输出5条log。然后关闭fluentd，继续输出15条log，启动fluentd，fluent-logger自动连接上fluentd，并将缓存的15条log发送至fluentd</li></ul><p>以上测试表明fluentd-logger在与fluentd丢失连接时，相关log暂先会缓存起来，并在重连时将缓存的log发送至fluentd。这个机制相当优秀，大大增加了安全性，不过要注意缓存是占用内存的，如果长时间连接不上fluentd，有内存耗尽的风险。</p><h3 id="日志解决方案实战"><a href="#日志解决方案实战" class="headerlink" title="日志解决方案实战"></a>日志解决方案实战</h3><p>可参考文档：<a href="https://blog.csdn.net/shiwenqing/article/details/50475330" target="_blank" rel="noopener">基于Elasticsearch+Fluentd+Kibana的日志收集分析系统搭建与应用</a><br></p><h3 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h3><p>fluentd收集数据，可输出到hadoop中，利用数据做数据挖掘，可以实现很多有价值的目标。比如：</p><ul><li>监测用户行为，针对流失较高的点，优化流失率，提高留存</li><li>监测消费行为，针对性营销，增加收入</li><li>异常检测，发现数据异常情况，第一时间发现服务器逻辑漏洞</li><li>消费数据挖掘，将消费者分类，同类消费者商品推荐</li><li>发现即将流失客户，重点给与相关优惠吸引策略</li><li>发现核心用户，重点关注</li><li>…</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.fluentd.org/" target="_blank" rel="noopener">Fluent</a><br><br><a href="https://github.com/fluent/fluentd-benchmark/tree/master/one_forward" target="_blank" rel="noopener">fluentd-benchmark</a><br><br><a href="https://docs.fluentd.org/v1.0/articles/quickstart" target="_blank" rel="noopener">Fluent doc</a><br><br><a href="https://blog.csdn.net/shiwenqing/article/details/50475330" target="_blank" rel="noopener">基于Elasticsearch+Fluentd+Kibana的日志收集分析系统搭建与应用</a><br><br><a href="https://logz.io/blog/fluentd-logstash/" target="_blank" rel="noopener">Fluentd vs. Logstash: A Comparison of Log Collectors</a><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近公司想要统一管理各个项目的日志，也为以后日志可视化查询做一个铺垫。经过筛选，选择了fluentd来做日志的收集转发工作，预想利用EFK来做日志收集、查询、可视化的方案。&lt;br&gt;&lt;br&gt;啥？你问我为啥不用Logstash，可参考文章&lt;a href
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>内存管理</title>
    <link href="http://liangiter.top/2018/09/29/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://liangiter.top/2018/09/29/内存管理/</id>
    <published>2018-09-29T11:27:34.000Z</published>
    <updated>2018-10-09T01:47:43.779Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote><p>内存管理不恰当，会有造成大量内存碎片、内存分配效率低、内存实际使用率低。在程序运行中，这些问题会导致程序无法持久正常运行，于服务器技术而言更是如此。</p></blockquote><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>内存管理可以分为三个层次，自底向上分别是：</p><ul><li>操作系统内核的内存管理</li><li>使用系统调用维护的内存管理算法</li><li>在上一步基础上，根据应用程序本身的程序特性进行优化， 比如使用引用计数、内存池方式等</li></ul><p><strong>本文我们主要讨论第二步的使用系统调用维护的内存管理算法</strong></p><p>对于需要持久运行的程序而言，内存管理十分重要，一个优秀的内存管理策略应该具有如下特性：</p><ul><li>分配速度尽可能快</li><li>内存碎片尽可能少</li><li>内存实际使用率高</li></ul><h3 id="memcached内存管理机制"><a href="#memcached内存管理机制" class="headerlink" title="memcached内存管理机制"></a>memcached内存管理机制</h3><blockquote><p>memcached是一个知名的高效的分布式内存cache，默认使用SlabAllocation机制管理内存，其主要思想是按照预先规定的大小，将分配的内存分割成特定长度的块以存储相应长度的key-value数据记录，以完全解决内存碎片问题。</p></blockquote><p>Slab和Chunk<br><br><img src="/2018/09/29/内存管理/memcached内存结构图.png" alt="memcached内存结构图"><br><br>slab是memcached一次申请内存的最小单位。memcached启动时使用参数-m指定其可用内存，但并不是启动时所有的内存就全部分配出去了，只有在需要时才会去申请，而且每次申请一定是一个slab。Slab的大小固定为1M（1048576 Byte）。</p><p>一个slab由若干个大小相等的chunk组成。每个chunk中都保存了一个item结构体、一对key和value。</p><p>虽然在同一个slab中chunk的大小相等的，但是在不同的slab中chunk的大小并不一定相等，在memcached中按照chunk的大小不同，可以把slab分为很多种类（class）。</p><p>在启动memcached的时候可以通过-vv来查看slab的种类：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ memcached -vv</span><br><span class="line">slab class <span class="number">1</span>: chunk size <span class="number">80</span> perslab <span class="number">13107</span></span><br><span class="line">slab class <span class="number">2</span>: chunk size <span class="number">104</span> perslab <span class="number">10082</span></span><br><span class="line">slab class <span class="number">3</span>: chunk size <span class="number">136</span> perslab <span class="number">7710</span></span><br><span class="line">slab class <span class="number">4</span>: chunk size <span class="number">176</span> perslab <span class="number">5957</span></span><br><span class="line">slab class <span class="number">5</span>: chunk size <span class="number">224</span> perslab <span class="number">4681</span></span><br><span class="line">slab class <span class="number">6</span>: chunk size <span class="number">280</span> perslab <span class="number">3744</span></span><br><span class="line">slab class <span class="number">7</span>: chunk size <span class="number">352</span> perslab <span class="number">2978</span></span><br><span class="line">slab class <span class="number">8</span>: chunk size <span class="number">440</span> perslab <span class="number">2383</span></span><br><span class="line">slab class <span class="number">9</span>: chunk size <span class="number">552</span> perslab <span class="number">1899</span></span><br><span class="line">slab class <span class="number">10</span>: chunk size <span class="number">696</span> perslab <span class="number">1506</span></span><br><span class="line">slab class <span class="number">11</span>: chunk size <span class="number">872</span> perslab <span class="number">1202</span></span><br><span class="line">slab class <span class="number">12</span>: chunk size <span class="number">1096</span> perslab <span class="number">956</span></span><br><span class="line">slab class <span class="number">13</span>: chunk size <span class="number">1376</span> perslab <span class="number">762</span></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br></pre></td></tr></table></figure><p>向memcached添加item时，memcached首先会根据item大小，根据chunk size向上取整，来选择接近的slab class。例如，item大小为156，向上取最小的chunk size为176.</p><p>memcached采取SlabAllocation策略，一次向系统申请1M空间内存作为slab。slab根据其chunk size分割成等大的内存块chunk，每个chunk都可以存储一个item。memcached内存分配做到了一次申请大量空间，分割多块给小对象多次使用，大大降低了向操作系统申请内存的时间，大部分内存管理机制都会用到这个策略。<br><br>其次，memcached将slab按chunk size分组，将每一个slab内部按chunk size分割成固定大小的内存块。固定大小的chunk，回收之后还可以用于下一次item的存储，内存的分布情况不会变的错综复杂，有利于减少内存碎片。chunk size递增策略，每一次item都向上取到最接近的chunk size对应的slab来存储，有利于提高其实际内存利用率<br></p><h3 id="Redis内存管理机制"><a href="#Redis内存管理机制" class="headerlink" title="Redis内存管理机制"></a>Redis内存管理机制</h3><blockquote><p>Redis默认使用jemalloc作为内存分配器。jemalloc 是一个通用的 malloc（3）实现，它强调了分段回避和可伸缩并发支持。jemalloc 在 2005 年首次作为 FreeBSD libc 分配器使用，2010年，jemalloc 的功能延伸到如堆分析和监控/调优等。现代的 jemalloc 版本依然集成在 FreeBSD 中。</p></blockquote><p>jemalloc机制相对memcached的SlabAllocation策略来说比较复杂，这里不做详细介绍，详情可参考本文列出的参考文档。</p><p>类似的，对jemalloc策略总结如下：</p><ul><li>一次向系统申请大内存4M（chunk），供之后多次使用</li><li>将控制的内存分成不同大小的小内存块（bins），重复使用</li><li>存放对象时，向上找到最接近size的bin对应的空闲内存块来存储</li><li>每个线程有自己的独立空间tcache，将内存划分为arena供线程使用，减少线程间的互斥访问</li></ul><p>前三条策略的思想与memcached的SlabAllocationc策略所蕴含的思想一致，第四条策略是针对多线程加速的优化。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://blog.csdn.net/junlon2006/article/details/77854898" target="_blank" rel="noopener"><strong>内存优化总结:ptmalloc、tcmalloc和jemalloc</strong></a><br><br><a href="https://blog.csdn.net/peerless_hero/article/details/77061927" target="_blank" rel="noopener"><strong>memcached的内存管理机制</strong></a><br><br><a href="https://www.cnblogs.com/gaoxing/p/4253833.html" target="_blank" rel="noopener"><strong>jemalloc和内存管里</strong></a><br><br><a href="https://people.freebsd.org/~jasone/jemalloc/bsdcan2006/jemalloc.pdf" target="_blank" rel="noopener"><strong>A Scalable Concurrent malloc(3) Implementation for FreeBSD</strong></a><br><br><a href="https://blog.csdn.net/koozxcv/article/details/50973217" target="_blank" rel="noopener"><strong>jemalloc内存分配器详解</strong></a><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;内存管理不恰当，会有造成大量内存碎片、内存分配效率低、内存实际使用率低。在程序运行中，这些问题会导致程序无法持久正
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>十步学习法</title>
    <link href="http://liangiter.top/2018/09/25/%E5%8D%81%E6%AD%A5%E5%AD%A6%E4%B9%A0%E6%B3%95/"/>
    <id>http://liangiter.top/2018/09/25/十步学习法/</id>
    <published>2018-09-25T11:59:29.374Z</published>
    <updated>2018-09-28T06:19:16.916Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在看《软技能：代码之外的生存指南》，作者分享他自己的学习方法——十步学习法。自己感觉平时学习新技术套路大致也是这样，不过自己并没有做过细致的总结和归纳，这里做一个简单的摘录和分享，详细情况可以去阅读原作，作者是一位充满激情、兴趣广泛、热爱生活、热爱思考而小有成就的技术人员，书本与技术有关，而不局限于技术，对任何人都有借鉴意义。</p></blockquote><h2 id="十步学习法"><a href="#十步学习法" class="headerlink" title="十步学习法"></a>十步学习法</h2><h3 id="1-了解全局"><a href="#1-了解全局" class="headerlink" title="1.了解全局"></a>1.了解全局</h3><h3 id="2-确定范围"><a href="#2-确定范围" class="headerlink" title="2.确定范围"></a>2.确定范围</h3><h3 id="3-定义目标"><a href="#3-定义目标" class="headerlink" title="3.定义目标"></a>3.定义目标</h3><h3 id="4-寻找资源"><a href="#4-寻找资源" class="headerlink" title="4.寻找资源"></a>4.寻找资源</h3><h3 id="5-创建学习计划"><a href="#5-创建学习计划" class="headerlink" title="5.创建学习计划"></a>5.创建学习计划</h3><h3 id="6-筛选资源"><a href="#6-筛选资源" class="headerlink" title="6.筛选资源"></a>6.筛选资源</h3><h3 id="7-开始学习，浅尝辄止"><a href="#7-开始学习，浅尝辄止" class="headerlink" title="7.开始学习，浅尝辄止"></a>7.开始学习，浅尝辄止</h3><h3 id="8-动手操作，边学边玩"><a href="#8-动手操作，边学边玩" class="headerlink" title="8.动手操作，边学边玩"></a>8.动手操作，边学边玩</h3><h3 id="9-全面掌握，学以致用"><a href="#9-全面掌握，学以致用" class="headerlink" title="9.全面掌握，学以致用"></a>9.全面掌握，学以致用</h3><h3 id="10-乐为人师，融会贯通"><a href="#10-乐为人师，融会贯通" class="headerlink" title="10.乐为人师，融会贯通"></a>10.乐为人师，融会贯通</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近在看《软技能：代码之外的生存指南》，作者分享他自己的学习方法——十步学习法。自己感觉平时学习新技术套路大致也是这样，不过自己并没有做过细致的总结和归纳，这里做一个简单的摘录和分享，详细情况可以去阅读原作，作者是一位充满激情、兴趣广泛、热爱生活、
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>垃圾回收机制</title>
    <link href="http://liangiter.top/2018/09/25/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://liangiter.top/2018/09/25/垃圾回收机制/</id>
    <published>2018-09-25T09:16:45.129Z</published>
    <updated>2018-09-25T09:56:23.021Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>近期公司技术分享讲座十分火热，近期我做了有关垃圾回收机制的分享，整理一下文档</p></blockquote><h3 id="垃圾回收背景"><a href="#垃圾回收背景" class="headerlink" title="垃圾回收背景"></a>垃圾回收背景</h3><blockquote><p>John McCarthy 身为 Lisp 之父和人工智能之父，同时，他也是 GC 之父。1960 年，他在其论文中首次发布了 GC 算法（其实是委婉的提出😂）。而 Java 的前身 Oak 是在 1990 发布的，利用 JVM 实现了跨平台。GC 因此一举成名。</p></blockquote><h3 id="垃圾回收基本概念"><a href="#垃圾回收基本概念" class="headerlink" title="垃圾回收基本概念"></a>垃圾回收基本概念</h3><p>基本概念:</p><ul><li>全集</li><li>根集</li><li>可达到的对象集合</li><li>不可达到的对象集合</li></ul><h4 id="垃圾的定义"><a href="#垃圾的定义" class="headerlink" title="垃圾的定义"></a>垃圾的定义</h4><p>引用《垃圾回收的算法与实现》书中的话:</p><blockquote><p>把分配到堆中那些不能通过程序引用的对象称为非活动对象，也就是死掉的对象，我们称为“垃圾”。</p></blockquote><ul><li>程序无法访问的对象</li><li>GC 收集器需要能正确找到垃圾对象并销毁之</li></ul><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>因为我们期望让内存管理变得自动（只管用内存，不管内存的回收），我们就必须做两件事情：</p><blockquote><p>找到内存空间里的垃圾回收垃圾，让程序员能再次利用这部分空间 [1] 只要满足这两项功能的程序，就是 GC，不论它是在 JVM 中，还是在 Ruby 的 VM 中。但这只是两个需求，并没有说明 GC 应该何时找垃圾，何时回收垃圾等等更具体的问题，各类 GC 算法就是在这些更具体问题的处理方式上施展手脚。</p></blockquote><h4 id="全集"><a href="#全集" class="headerlink" title="全集"></a>全集</h4><ul><li>进程内存中全部对象的集合</li><li>以 Python 为例:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gc.get_objects()</span><br></pre></td></tr></table></figure><h4 id="根集"><a href="#根集" class="headerlink" title="根集"></a>根集</h4><ul><li>不用通过引用关系,可以直接访问对象的集合</li></ul><h4 id="可达对象集合"><a href="#可达对象集合" class="headerlink" title="可达对象集合"></a>可达对象集合</h4><ul><li>根集的对象</li><li>通过可达对象,利用引用关系遍历到的所有对象<br><img src="/2018/09/25/垃圾回收机制/reachable.png" alt="imag"></li></ul><h4 id="不可达到的对象集合"><a href="#不可达到的对象集合" class="headerlink" title="不可达到的对象集合"></a>不可达到的对象集合</h4><ul><li>全集与可达对象集合差集</li><li>不可达对象是垃圾</li><li>Python 中 gc.collect()后垃圾存在列表 gc.grabage 中</li></ul><h4 id="垃圾回收的优点"><a href="#垃圾回收的优点" class="headerlink" title="垃圾回收的优点"></a>垃圾回收的优点</h4><ul><li>提高编程效率</li><li>避免内存泄漏</li><li>野指针 (悬垂指针)</li><li>释放错误的内存</li></ul><blockquote><p>内存泄露：忘记释放了某一部分内存，会导致那部分内存不可用，并占用总的内存空间。如果这一现象持续发生，会引起内存被占满，系统崩溃悬垂指针：忘记初始化指向释放了的内存的指针。这会导致再次调用指针时，该指针指向空内存，引起 bug 释放错误的内存：人为的操作难免会发生错误，如果释放了错误的内存，也会导致程序发生莫名其妙的 bug</p></blockquote><blockquote><p>由此可见垃圾回收的重要性，既可以减少程序员的工作量，更重要的是可以避免很多不必要的错误。</p></blockquote><h4 id="垃圾回收缺点"><a href="#垃圾回收缺点" class="headerlink" title="垃圾回收缺点"></a>垃圾回收缺点</h4><ul><li>垃圾回收消耗cpu，影响程序性能</li></ul><h4 id="垃圾回收性能评价"><a href="#垃圾回收性能评价" class="headerlink" title="垃圾回收性能评价"></a>垃圾回收性能评价</h4><ul><li>垃圾回收总时间</li><li>进程突然的停顿</li><li>空间利用 —— 减少内存碎片 - 空间连续性、时间连续性</li><li>以上要求互相制衡，需要折中</li></ul><h3 id="主流垃圾回收策略"><a href="#主流垃圾回收策略" class="headerlink" title="主流垃圾回收策略"></a>主流垃圾回收策略</h3><p>John McCarthy 身为 Lisp 之父和人工智能之父，同时，他也是 GC 之父。1960 年，他在其论文中首次发布了 GC 算法（其实是委婉的提出😂）。</p><p>标记-清除算法 由 John McCarthy 在 1960 年提出 引用计数法 由 George E. Collins 在 1960 年提出 此算法会有循环引用问题，Harold McBeth 1963 年指出。 复制算法 由 Marvin L. Minsky 在 1963 年提出</p><p>《垃圾回收》的作者认为：</p><blockquote><p>从 50 年前 GC 算法首次发布以来，众多研究者对其进行了各种各样的研究，因此许多 GC 算法也得以发布。[2] 但事实上，这些算法只不过是把前文中提到的三种算法进行组合或应用。也可以这么说，1963 年 GC 复制算法诞生时，GC 的根本性内容就已经完成了。</p></blockquote><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>垃圾回收关注的是对于不会再次被使用的对象的内存回收，换一种说法，对于会被垃圾回收清理的对象（内存），不会再次的被其他对象引用。那么可以为每一个对象引入一个计数器，对于任意一个对象，每有一次对这个对象的引用，就将计数器加 1；结束对这个对象的引用，再将计数器减 1；一旦计数器归 0，则表示这个对象可以被清除。这就是引用计数法。</p><p>由于在计数器归 0 后，可以立即知道这个对象成为了垃圾，所以引用计数法有着即使回收的优点。同样，这个算法也不是完美的，存在着一定的缺点：</p><ul><li>占用资源：因为每个对象都需要维护一个计数器，每次指针有更新都伴随着计数器的更新，一定程度上占用了计算资源</li><li>占用内存：计数器需要占用一定的内存，为了安全起见，计数器值的上限要大于所有对象的上限，这也是一笔不小的开销</li><li>实现复杂：虽然引用计数的思想简单，但是实现起来却不那么容易。各位可以思考下，如果自己编写这一算法，该如何实现？</li><li>无法解决循环引用：就像会有狗狗喜欢咬自己的尾巴，把自己咬成环，对象也会存在循环的引用。假设两个对象 a 和 b，a 有指向 b 的指针，b 有指向 a 的指针。二者可能一起成为垃圾，一旦这种情况发生，由于存在对对方的引用，它们的计数器永远都不会归 0，它们也不会被回收</li></ul><h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p>正如算法的名字，标记清除法可以划分成两个阶段，标记和清除：</p><ul><li>标记</li><li><ul><li>标记根集中的所有对象为可达</li></ul></li><li><ul><li>从根集中的对象遍历，将其引用的对象标记为可达</li></ul></li><li><ul><li>迭代第二步，找到所有可达对象</li></ul></li><li><p>清除</p></li><li><ul><li>全集与可达对象集合的差集，标记为不可达对象集合</li></ul></li><li><ul><li>销毁所有不可达对象</li></ul></li></ul><p><img src="/2018/09/25/垃圾回收机制/ref_count.png" alt="imag"></p><p>优点</p><ul><li>思路简单，实现简单，是这个算法的一大优点.</li><li>没有额外内存开销</li><li>可以正确销毁循环引用的对象</li></ul><p>缺点</p><p>简单也意味着在其他部分有所牺牲，从上图我们可以看出一些端倪：碎片化：由于只是将垃圾对象清除掉，对于存活对象不做处理，所以由于存活对象分布的不连续性，会导致可用内存被分割成一块块的。如果有一个新的对象请求内存，需要去内存中寻找，哪一个空闲块（可用一个链表来维护空闲块的位置）足够满足这个对象的需求。更极端的情况，空闲的总内存大于对象请求的空间，却没有足够的连续空闲空间，来完成内存的分配。与写时复制技术不兼容：写时复制（Copy On Write）是一个很重要的思想，可以优化内存占用或者提升并发环境下的性能。顾名思义，这一技术是在有写入的时候，对内存进行复制，以达到一定的优化目的。而标记清除算法的标记过程，就是一次对内存（对象头）的写入，会不断地引起内存复制。因此标记清除算法与此技术并不互相兼容</p><ul><li>标记-清除操作时间消耗较大，程序会顿卡</li><li>对象不可达后，销毁有延时</li></ul><p><img src="/2018/09/25/垃圾回收机制/ref_count2.png" alt="imag"></p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>在复制算法中，先将内存分为两个部分，From 区和 To 区，两部分大小相等。对象分配时，只会在 From 区进行分配。复制算法可以分两步，第一步为类似标记清除算法的标记，在 From 区中，找出所有活动的对象。区别在于第二步。复制算法会把这些活动的对象，复制到 To 区中，再将原有的 From 区全部清空，并交换两部分内存的职责，即一次 GC 后，原有的 From 区会成为 To 区，To 区相反。</p><p><img src="/2018/09/25/垃圾回收机制/copy.png" alt="imag"></p><p>优点<br>复制算法的优点相比于另外两个算法还是多一些的：</p><p>效率快：相比于标记清除算法，复制算法在标记阶段，只需要标记哪些对象是活动的就可以了，相比于标记清除算法需要遍历所有的对象，性能上有提升不会发生碎片化：同样相比于标记清除算法，由于存活下来的对象会在 To 区中连续的分配，因此不会像标记清除算法那样，需要维护碎片空间分配速度快：由于不会发生碎片化，如果有一个新的对象请求内存，那么分配时可以直接追加在 From 区已用内存之后，分配的速度快.</p><p>缺点<br>同样复制算法也不是十全十美，它也有着如下的缺点：内存使用率低：由于复制算法把内存分成了两块，那么对于对象的可用空间来说，仅仅是其他算法的一半自对象的递归复制：一个对象通常会关联一些自对象。在复制这些对象的时候，还需要递归的去处理它的自对象，这通常会产生一定的开销。同时，在递归调用时，存在着函数栈的消耗，潜藏着栈溢出的风险</p><h4 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h4><ul><li>不可到达对象在内存中是分散的，回收对象后，空闲内存是分段的</li><li>移动可到达的堆对象，保持内存连续<br><img src="/2018/09/25/垃圾回收机制/relocate.png" alt="imag"></li></ul><h4 id="分代算法"><a href="#分代算法" class="headerlink" title="分代算法"></a>分代算法</h4><ul><li>销毁的总是年轻的对象<br>— 统计表明：80%-90%新分配的对象会在随后几百万条指令周期内销毁</li><li>将堆空间分成几块</li><li>新对象生成在空间1</li><li>当空间1满了，将对象移动到空间2，再往上也如此类推</li><li>空间序号越小，垃圾回收检测越频繁</li><li>Python分为三代，gc.get_threshold可以获取每一代空间的默认阈值</li></ul><h3 id="各语言的垃圾回收策略"><a href="#各语言的垃圾回收策略" class="headerlink" title="各语言的垃圾回收策略"></a>各语言的垃圾回收策略</h3><table><thead><tr><th>Luanguage</th><th>引用计数</th><th>标记-清除</th><th>分代</th><th>重定位</th><th>复制</th></tr></thead><tbody><tr><td>Python</td><td>√</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>JavaScript</td><td>√</td><td>√</td><td></td><td></td><td></td></tr><tr><td>Java</td><td>√</td><td>√</td><td></td><td></td><td>√</td></tr><tr><td>Golang</td><td>√</td><td></td><td></td><td></td><td></td></tr></tbody></table><blockquote><p>1、JavaScript 中 BOM、COM 用的是引用计数机制<br><br>2、Golang 最新用的是三色标记-清除算法，标记阶段需要 STW，清除阶段可以并发进行</p></blockquote><h3 id="Python垃圾回收实战"><a href="#Python垃圾回收实战" class="headerlink" title="Python垃圾回收实战"></a>Python垃圾回收实战</h3><p>以 Python 为例 Python 的 gc.collect() 标记-清除需要消耗一定时间，在对象数量达到百万级别时会有秒级卡顿。有些项目对实时性要求比较高，会调用 gc.disable()关闭 gc；关闭 gc 意味着在开发阶段就要解除所有的循环引用，不然会造成内存泄漏。即使不关闭 gc，在销毁对象时解除循环引用，有利于减少 gc 卡顿时间。那如何找到循环引用的对象？如何找出引用环的情况？</p><blockquote><p>gc.DEBUG_SAVEALL When set, all unreachable objects found will be appended to garbage rather than being freed. This can be useful for debugging a leaking program.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gc.set_debug(gc.DEBUG_SAVEALL)</span><br><span class="line">gc.collect()</span><br><span class="line">print(gc.garbage)</span><br></pre></td></tr></table></figure><p>上面的方法可以找到垃圾对象，但要靠自己去找到对象间的引用情况来解除引用。利用 objgraph 可以找到对象的引用关系链并生成图。但是在实践中，进程中对象数量较大时，objgraph 经常会慢到让人想要原地自爆。也可以自己编写工具，在 gc.garbage 做图的遍历，找到所有的环引用，这样会比较全比较快。(TODO: 待分享通过gc.garbage查环工具代码)<br><img src="/2018/09/25/垃圾回收机制/obj_graph.png" alt="imag"></p><blockquote><p>gc.garbage <br><br>A list of objects which the collector found to be unreachable but could not be freed (uncollectable objects). By default, this list contains only objects with <strong>del</strong>() methods. [1] Objects that have <strong>del</strong>() methods and are part of a reference cycle cause the entire reference cycle to be uncollectable, including objects not necessarily in the cycle but reachable only from it. Python doesn’t collect such cycles automatically because, in general, it isn’t possible for Python to guess a safe order in which to run the <strong>del</strong>() methods. If you know a safe order, you can force the issue by examining the garbage list, and explicitly breaking cycles due to your objects within the list. Note that these objects are kept alive even so by virtue of being in the garbage list, so they should be removed from garbage too. For example, after breaking cycles, do del gc.garbage[:] to empty the list. It’s generally better to avoid the issue by not creating cycles containing objects with <strong>del</strong>() methods, and garbage can be examined in that case to verify that no such cycles are being created.</p></blockquote><blockquote><p>If DEBUG_SAVEALL is set, then all unreachable objects will be added to this list rather than freed.</p></blockquote><p>有个很重要的点，Python2 中，当对象形成环引用，即使开启 gc，实现了<strong>del</strong>方法的对象也无法被回收，因为 gc 并不知道在<strong>del</strong>方法中是否对引用的对象有操作，无法确定正确的回收顺序。在Python 中，一般而言，尽量不要实现<strong>del</strong>方法，而改用其他方法在销毁时手动调用之。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;近期公司技术分享讲座十分火热，近期我做了有关垃圾回收机制的分享，整理一下文档&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;垃圾回收背景&quot;&gt;&lt;a href=&quot;#垃圾回收背景&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收背景&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>通用技术总结</title>
    <link href="http://liangiter.top/2018/09/21/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    <id>http://liangiter.top/2018/09/21/通用技术总结/</id>
    <published>2018-09-21T07:51:30.946Z</published>
    <updated>2018-09-27T01:12:52.292Z</updated>
    
    <content type="html"><![CDATA[<p>选择一门技术，要综合考量技术的多个方面来评估。大方向上首先考虑<code>技术综合面</code>：</p><ol><li>业界是否有知名的成功案例；</li><li>是否有强大后援；</li><li>是否有活跃的开发者论坛；</li></ol><p>业界有知名成功案例意味着该技术通过了技术人员的考究，经过了工程的检验，坑也会相对较少。<br>比如Java有Sun，Golang有Google，有这些实力雄厚的公司或机构做背书，有理由相信这些技术未来的潜力；<br>java、python有活跃的论坛，有丰富开源库，做网络应用、缓存、爬虫等工作都有现成的库，无需造轮，大大提高开发效率。另外，有活跃的开发者论坛意味着技术资料比较丰富，并且绝大部分你遇到的问题都有前人遇到过，可以大大减少爬坑的时间。</p><p>业务需求会对系统有一些要求，根据业务特点考虑以下问题：</p><ol><li>计算密集型、IO密集型：计算密集型与IO密集型的任务会对系统有不同的要求；计算密集型任务可以考虑编译型语言、多核&amp;多机（分布式）来实现。多核IO密集型任务并没有什么帮助，多路复用会有好的效果。</li><li>读写频率：不同的读写频率有不同适用的数据结构和算法，会衍生出不同的系统架构；</li><li>系统实时性要求：实时性要求高的系统需要快速响应，服务线程需要避免长时间堵塞式的调用，可以利用并行、分时、多路复用等特性；</li><li>系统安全性要求：服务器连续运行时间要求、数据一致性要求，分布式系统需要考虑CAP问题；</li><li>热更新、热部署：在虚拟机中运行的脚本语言更适合热部署；</li><li>平衡开发效率与运行效率：一般而言抽象层次较高的脚本语言开发效率较高，但运行效率较差；封装程度较低的编译型语言运行效率较高，但开发效率较差；</li><li><code>技术综合面</code>：参考本文前面的对<code>技术综合面</code>的说明；</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;选择一门技术，要综合考量技术的多个方面来评估。大方向上首先考虑&lt;code&gt;技术综合面&lt;/code&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;业界是否有知名的成功案例；&lt;/li&gt;
&lt;li&gt;是否有强大后援；&lt;/li&gt;
&lt;li&gt;是否有活跃的开发者论坛；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;业界有知名
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>游戏全球同服服务器框架</title>
    <link href="http://liangiter.top/2018/09/21/%E5%85%A8%E7%90%83%E5%90%8C%E6%9C%8D%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/"/>
    <id>http://liangiter.top/2018/09/21/全球同服游戏服务器框架/</id>
    <published>2018-09-21T07:40:02.642Z</published>
    <updated>2018-09-21T07:42:17.452Z</updated>
    
    <content type="html"><![CDATA[<p>背景：</p><blockquote><p>最近公司要开发一款全球同服，所有玩家可相互匹配战斗、相互加好友、相互聊天的游戏</p></blockquote><hr><p>服务器需要面临的需求有：</p><ul><li>玩家注册量要支持十亿量级</li><li>玩家在线量要支持千万到亿量级</li><li>所有在线玩家可相互通信</li><li>十亿级别玩家名模糊搜索</li></ul><p>需要支持如此量级的连接，必须要消除服务器进程的单点问题，玩家客户端能够均匀的连接到各个服务器进程上。<br>如果玩家可动态选择连接的进程，轻则面临rpc没有命中、重则引发数据回档问题。玩家根据一定的规则均匀Hash到服务器各个进程中，玩家对应的进程固定，不用担心rpc命中和数据存盘的时序问题。</p><p>对于各种服务，类似好友、战斗匹配而言，都不能出现单点。每种服务都是由多进程协同组成功能集群，功能集群对外提供高并发服务。集群服务进程可以用一致性hash规则来选择。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;背景：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最近公司要开发一款全球同服，所有玩家可相互匹配战斗、相互加好友、相互聊天的游戏&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;服务器需要面临的需求有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;玩家注册量要支持十亿量级&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python内存泄露查询</title>
    <link href="http://liangiter.top/2018/09/21/Python%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%9F%A5%E8%AF%A2/"/>
    <id>http://liangiter.top/2018/09/21/Python内存泄露查询/</id>
    <published>2018-09-21T07:40:02.633Z</published>
    <updated>2018-09-21T07:50:17.995Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">需求背景</span><br><span class="line">最近项目在压力测试期间，进程在运行中内存持续增加，物理内存很快就被消耗殆尽。为了服务器能持久提供服务，需要对内存进行诊断。</span><br><span class="line">本文讨论Python层内存对象的检查，CPython扩展产生的泄露不在本文讨论范围。</span><br></pre></td></tr></table></figure><p>Python垃圾回收机制背景：</p><p>Python利用引用计数进行垃圾回收，当引用为0时，对象会被虚拟机析构内存会被释放。环引用则需要通过 <strong>标记-清除算法</strong>(<code>Mark-Sweep</code>) 来销毁对象。如果对象实现了<strong>del</strong>方法，由于gc无法断定销毁是否会影响<strong>del</strong>的调用，故gc无法处理此类对象而产生垃圾。</p><h4 id="需要处理的异常情况包括："><a href="#需要处理的异常情况包括：" class="headerlink" title="需要处理的异常情况包括："></a>需要处理的异常情况包括：</h4><ul><li><strong>垃圾对象</strong>：gc概念上的垃圾对象</li><li><strong>泄露对象</strong>：对象在逻辑上应该被销毁，但是有外部引用，导致对象没有销毁</li><li><strong>环引用对象</strong>：环引用对象会增加gc的cpu消耗，会延长对象回收时间</li></ul><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ol><li>垃圾对象处理：Python类尽量不要实现<strong>del</strong>方法，用其他机制实现就能避免垃圾对象。</li><li>泄露对象解决：需要对逻辑层面十分了解，能知道如何判断一个对象是否是为逻辑层面应该销毁的对象。一般而言，对象用一个属性来标识是否已销毁，利用<code>gc.getobject</code>遍历对象全集，通过标识进行判断就能找出不正常的对象。利用<code>objgraph.show_chain(objgraph.find_backref_chain(obj, objgraph.is_proper_module))</code>生成引用链，解除异常引用解决问题。</li><li>环引用对象处理：先<code>gc.set_debug(gc.DEBUG_SAVEALL)</code>，然后<code>gc.collect()</code>，再通过对<code>gc.garbage</code>里的对象利用引用关系进<em>DFS</em>遍历，记录所有找到的环。对记录的环引用中的对象，在销毁的时候解除引用即可。</li></ol><h4 id="最后分享Python几个常用的内存调试工具："><a href="#最后分享Python几个常用的内存调试工具：" class="headerlink" title="最后分享Python几个常用的内存调试工具："></a>最后分享Python几个常用的内存调试工具：</h4><ul><li><p><a href="https://pypi.python.org/pypi/memory-tools/1.0.5" target="_blank" rel="noopener">memory-tools</a>模块，summarize_objects()可以统计内存中各个class实例数量和所占内存量，并排序输出。可以通过查看对象数量和内存量来分析异常情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Objects count 3,790</span><br><span class="line">Objects size 833,344</span><br><span class="line"></span><br><span class="line">      Size Count Type</span><br><span class="line">   476,864   296 &lt;type &apos;dict&apos;&gt;</span><br><span class="line">    76,320   954 &lt;type &apos;wrapper_descriptor&apos;&gt;</span><br><span class="line">    64,920   541 &lt;type &apos;function&apos;&gt;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">Count       Size Type</span><br><span class="line">  954     76,320 &lt;type &apos;wrapper_descriptor&apos;&gt;</span><br><span class="line">  541     64,920 &lt;type &apos;function&apos;&gt;</span><br><span class="line">  515     37,080 &lt;type &apos;builtin_function_or_method&apos;&gt;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></li><li><p><a href="https://pypi.python.org/pypi/objgraph/3.1.2" target="_blank" rel="noopener">objgraph</a>模块，可以统计类型对应实例数量，统计类型增长情况，获得指定类型所有实例，<strong>获得指定对象的引用链</strong><img src="/2018/09/21/Python内存泄露查询/objgraph.png" alt="imag"></p></li><li><p><a href="https://pypi.python.org/pypi/memory_profiler/0.50.0" target="_blank" rel="noopener">memory_profiler</a>可对Python代码逐行显示Mem增量，便于发现内存消耗高的代码块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Line #    Mem usage  Increment   Line Contents</span><br><span class="line">==============================================</span><br><span class="line">     3                           @profile</span><br><span class="line">     4      5.97 MB    0.00 MB   def my_func():</span><br><span class="line">     5     13.61 MB    7.64 MB       a = [1] * (10 ** 6)</span><br><span class="line">     6    166.20 MB  152.59 MB       b = [2] * (2 * 10 ** 7)</span><br><span class="line">     7     13.61 MB -152.59 MB       del b</span><br><span class="line">     8     13.61 MB    0.00 MB       return a</span><br></pre></td></tr></table></figure></li><li><p><a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html" target="_blank" rel="noopener">TCMalloc</a><br>Google内存工具，利用tcmalloc 来代替malloc calloc new等等，这样Google Heap Profiler就能知道内存的分配情况，从而分析出内存问题。这种机制可以监测所有程序语言的内存分配情况来分析内存问题。<br>TCMalloc也包括一个堆检查器 和堆分析器。<br><br><a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html" target="_blank" rel="noopener">官网</a><br><br><a href="http://www.cnblogs.com/my_life/articles/4661790.html" target="_blank" rel="noopener">安装</a><br><br><a href="http://blog.csdn.net/jhzhou/article/details/7245992" target="_blank" rel="noopener">使用</a></p></li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://yyc.solvcon.net/writing/2015/pymem_survey.html" target="_blank" rel="noopener">Python内存分析工具文章链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PythonCPU诊断优化</title>
    <link href="http://liangiter.top/2018/09/21/PythonCPU%E8%AF%8A%E6%96%AD%E4%BC%98%E5%8C%96/"/>
    <id>http://liangiter.top/2018/09/21/PythonCPU诊断优化/</id>
    <published>2018-09-21T07:40:02.628Z</published>
    <updated>2018-09-21T07:41:52.348Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>无论用什么语言来实现需求，最后基本都会需要对代码运行时间进行优化，降低cpu占用率</p></blockquote><p>这里主要介绍两个profile工具：</p><ol><li>cProfile：用cProfile生成程序运行时的profile文件，用<code>python pyprof2calltree.py -i file</code>生成文件供QCacheGrind读取；然后用qcachegrind.exe查看，可以看到图像化的代码情况，面积表示cpu占比，可以很方便的找到cpu占比高的代码来进行优化。</li><li>vmprof：vmprof支持pypy，先用vmprof生成profile文件（<code>pypy -m vmprof -o log.jit example.py</code>），用<code>vmprofshow log.jit</code>来查看代码占用cpu情况；</li></ol><p>cprofile图形化结果更加强大，但是不支持pypy。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;无论用什么语言来实现需求，最后基本都会需要对代码运行时间进行优化，降低cpu占用率&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里主要介绍两个profile工具：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;cProfile：用cProfile生成程序运行时的pro
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Pomelo压测.md</title>
    <link href="http://liangiter.top/2018/09/21/pomelo%E5%8E%8B%E6%B5%8B/"/>
    <id>http://liangiter.top/2018/09/21/pomelo压测/</id>
    <published>2018-09-21T07:40:02.624Z</published>
    <updated>2018-09-29T06:25:47.158Z</updated>
    
    <content type="html"><![CDATA[<p>网易开源JavaScript分布式服务器架构Pomelo<br><a href="https://github.com/NetEase/pomelo/wiki/Home-in-Chinese" target="_blank" rel="noopener">中文文档</a></p><p>Pinus一个基于Node.js的分布式水平扩展游戏服务器轻量级强大框架 powered by TypeScript<br><a href="http://pinus.io/" target="_blank" rel="noopener">链接</a></p><blockquote><p>项目对服务器架构进行长久布局，采用网易的分布式游戏服务器Pomelo，需要对Pomelo性能进行压力测试</p></blockquote><!-- ## pomelo chat案例压力测试 --><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>下载pomelo <a href="https://github.com/NetEase/chatofpomelo-websocket.git" target="_blank" rel="noopener">chat聊天室源码</a>，初始化后做如下修改：</p><ul><li>修改<code>game-server/app.js</code>下<code>heartbeat : 3000000</code>，避免压测时因心跳超时而断线</li><li>修改<code>game-server/config/servers.json</code>，所有服务器只保留第一个配置，我们只测试单服单进程的负载</li><li>修改<code>web-server/public/js/client.js</code>，<a href="client.txt">代码传送门</a></li><li>修改<code>game-server/config/log4js.json</code>，将levels下所有的log配置都修改为ERROR（如下），减少后台打印量，避免大量IO影响压测<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"levels"</span>: &#123;</span><br><span class="line">    <span class="string">"rpc-debug"</span> : <span class="string">"ERROR"</span>,</span><br><span class="line">    <span class="string">"pomelo"</span> : <span class="string">"ERROR"</span>,</span><br><span class="line">    <span class="string">"pomelo-admin"</span> : <span class="string">"ERROR"</span>,</span><br><span class="line">    <span class="string">"console"</span> : <span class="string">"ERROR"</span>,</span><br><span class="line">    <span class="string">"pomelo-rpc"</span> : <span class="string">"ERROR"</span>,</span><br><span class="line">    <span class="string">"rpc-log"</span> : <span class="string">"ERROR"</span>,</span><br><span class="line">    <span class="string">"forward-log"</span>: <span class="string">"ERROR"</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li></ul><h3 id="测试方法："><a href="#测试方法：" class="headerlink" title="测试方法："></a>测试方法：</h3><ol><li>进入<code>http://127.0.0.1:3001/</code></li><li>聊天内容匹配<code>profile频率_持续时间</code>，则发起压测；频率为每秒发送消息数量，持续时间为压测持续时间。profile100_5表示每秒100条消息，持续压测5s</li><li>在压测过程中可以用perf工具对node进程进行profile并生成火焰图，<a href="https://www.cnblogs.com/happyliu/p/6142929.html" target="_blank" rel="noopener">profile参考文档</a></li></ol><h3 id="压测数据记录情况"><a href="#压测数据记录情况" class="headerlink" title="压测数据记录情况"></a>压测数据记录情况</h3><hr><blockquote><p>虚拟机压测，配置如下：<br><br>ubuntu-18.04.1-desktop-amd64<br><br>Intel(R) Core(TM) i5-8400 CPU @ 2.80GHz<br><br>RAM: 3.00G<br></p></blockquote><table><thead><tr><th>发包频率</th><th>connector_cpu</th><th>chat_server_cpu</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>10</td><td>1</td><td>1</td></tr><tr><td>100</td><td>5</td><td>1</td></tr><tr><td>500</td><td>28</td><td>6</td></tr><tr><td>1 000</td><td>50</td><td>10</td></tr><tr><td>2 000</td><td>85</td><td>20</td></tr><tr><td>2 500</td><td>95</td><td>25</td></tr></tbody></table><hr><blockquote><p>物理机压测，配置如下：<br><br>Windows 10 专业版 x64<br><br>Intel(R) Core(TM) i5-8400 CPU @ 2.80GHz  2.81GHz<br><br>RAM: 8.00G<br></p></blockquote><table><thead><tr><th>发包频率</th><th>connector_cpu</th><th>chat_server_cpu</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>500</td><td>6</td><td>3</td></tr><tr><td>1 000</td><td>7</td><td>3</td></tr><tr><td>2 000</td><td>15</td><td>6</td></tr><tr><td>5 000</td><td>33</td><td>9</td></tr><tr><td>8 000</td><td>30</td><td>8</td></tr></tbody></table><blockquote><p>当频率=8000，持续时间=30的时候，一共用了140s才将包全部处理完毕，此时的qps为 8000 * 30 / 140 = 1714。虽然此时的cpu并不是满载，但是吞吐量上不去了，Windows下测试比较奇怪。当频率=3000，持续时间=30的时候, qps为3000。当频率=4000，持续时间=30的时候，qps=2608；</p></blockquote><p><code>在ubuntu物理机测试结果最高qps也是3000多</code></p><p>在虚拟机ubuntu中，频率=1000， connector cpu=50，利用perf工具和FlameGraph生成的<a href="cpu.svg">火焰图</a><br><br><img src="/2018/09/21/pomelo压测/cpu.svg" alt="火焰图"><br><br><a href="perf.data">perf.data文件</a><br><br><a href="profile2.txt">easy node profile</a><br><br>目前profile结果还未中的代码还基本未涉及到代码逻辑部分，基本是框架底层固有消耗，还做不到去优化逻辑来提高qps。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在windows物理机和ubuntu物理机下，chat案例的connector最高的qps大约都在3000多<br><br>相对而言，系统的瓶颈是connector，压测中connector的cpu大约是game-server cpu的4倍<br><br>如果4个connector对应一个chat-server，chat-server qps预计能接近1W<br><br>这个这个性能作为棋牌游戏的服务器已经足够，如果作为MMO服务器则略显性能不足，需要用更高效的架构<br></p><p>附上官方测试文档，性能与我们测试的情况相差不大，connector cpu基本上是game-server的4倍<br><br><a href="https://github.com/NetEase/pomelo/wiki/pomelo-rpc%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A" target="_blank" rel="noopener">附pomelo rpc性能测试</a><br><br><a href="https://github.com/NetEase/pomelo/wiki/pomelo-rpc-zeromq%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A" target="_blank" rel="noopener">附pomelo rpc zeromq性能测试</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网易开源JavaScript分布式服务器架构Pomelo&lt;br&gt;&lt;a href=&quot;https://github.com/NetEase/pomelo/wiki/Home-in-Chinese&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中文文档&lt;/a&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>十亿级别字符串模糊匹配设计与实现</title>
    <link href="http://liangiter.top/2018/09/21/%E5%8D%81%E4%BA%BF%E7%BA%A7%E5%88%AB%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://liangiter.top/2018/09/21/十亿级别字符串模糊匹配设计与实现/</id>
    <published>2018-09-21T07:40:02.621Z</published>
    <updated>2018-09-21T07:42:38.320Z</updated>
    
    <content type="html"><![CDATA[<p>项目用mongodb作为数据库，mongodb支持索引，可对玩家名建立索引快速查找玩家名对应的项。模糊匹配方面，mongodb有提供全文匹配机制，可以用来实现模糊匹配需求。不过mongodb的全文匹配有两个缺点，一是中文版的全文匹配是收费功能，二是mongodb的全文匹配专业性、速度性都不是很成熟。使得项目不得不另外寻找新的实现方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ID = <span class="string">"59e1e6cd5c21ac436052300c"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Name = <span class="string">"玩家名字长度八字"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> sys.getsizeof(Name), sys.getsizeof(ID)</span><br><span class="line"></span><br><span class="line">(<span class="number">49</span>, <span class="number">57</span>)</span><br></pre></td></tr></table></figure><p>考虑利用游戏脚本逻辑来实现，用Python多进程协同组成集群方式来实现。这种方式自由度高、易维护、可控性强，在游戏服务器架构上无需要额外部署新的环境等诸多优点。元数据<code>玩家名， 玩家ID</code>在Python中所占内存约为110Byte，加上建立索引的消耗共占内存约200Byte，十亿玩家的数据量就是200GB。考虑到Python内存利用率低，群集内存消耗过大而放弃用Python脚本逻辑来实现。最后考虑用基于Lucene的全文搜索引擎Elasticsearch来实现这个功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;项目用mongodb作为数据库，mongodb支持索引，可对玩家名建立索引快速查找玩家名对应的项。模糊匹配方面，mongodb有提供全文匹配机制，可以用来实现模糊匹配需求。不过mongodb的全文匹配有两个缺点，一是中文版的全文匹配是收费功能，二是mongodb的全文匹配专
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Golang性能测试与思考</title>
    <link href="http://liangiter.top/2018/09/21/Golang%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%AF%84%E4%BB%B7/"/>
    <id>http://liangiter.top/2018/09/21/Golang性能测试与评价/</id>
    <published>2018-09-21T02:18:23.583Z</published>
    <updated>2018-09-21T06:37:18.893Z</updated>
    
    <content type="html"><![CDATA[<p>本文测试Go、Python、PyPy、C的效率，作为学习Go的参考标准。测试用例：进行(2&lt;&lt;25)次简单加法</p><blockquote><p>测试环境：<br><br>系统：Windows7 专业版<br><br>CPU：Intel(R) Core(TM) i5-4590 CPU @ 3.30GHZ 3.30GHZ, 14级流水线（Pipeline）<br> </p></blockquote><p>参考资料：<br><a href="https://zh.wikipedia.org/wiki/Core%E5%BE%AE%E6%9E%B6%E6%A7%8B" target="_blank" rel="noopener">Core微架构14级流水线</a></p><p>测试用例：进行(2&lt;&lt;25)次简单加法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang example</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> N <span class="keyword">int</span> = <span class="number">2</span> &lt;&lt; <span class="number">25</span></span><br><span class="line">    <span class="keyword">var</span> j <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    t0 := time.Now()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; (N); i++ &#123;</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    elapsed := time.Since(t0)</span><br><span class="line">    fmt.Println(<span class="string">"N:"</span>, N, <span class="string">"time:"</span>, elapsed)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：N: 67108864 time: 20.5027ms</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># Python and Pypy example</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">t0 = time.clock()</span><br><span class="line"></span><br><span class="line">N = <span class="number">2</span> &lt;&lt; <span class="number">25</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(N):</span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"N:&#123;&#125;, time:&#123;:.2f&#125;ms"</span>.format(N, (time.clock() - t0) * <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>测试结果：<br><br>Python N:67108864, time:5102.14ms<br><br>PyPy: N:67108864, time:124.16ms</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test1.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/timeb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined __linux__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">ClockMs64</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">timeb64</span> <span class="title">timebuffer</span>;</span></span><br><span class="line">    _ftime64_s(&amp;timebuffer);</span><br><span class="line">    <span class="keyword">return</span> timebuffer.time * <span class="number">1000</span> + timebuffer.millitm;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    timespec ts;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == clock_gettime(CLOCK_REALTIME, &amp;ts))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)ts.tv_sec) * <span class="number">1000</span> + ts.tv_nsec/<span class="number">1000000</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">Clock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>)ClockMs64();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    UINT64 N =  <span class="number">2</span> &lt;&lt; <span class="number">25</span>;</span><br><span class="line">    UINT64 j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> start = Clock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(UINT64 i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        j += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> end = Clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"N:%I64d, time:%dms\n"</span>, N, end-start);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：N:67108864, time:160ms</p><p>综合以上测试结果：<br></p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">时间</th></tr></thead><tbody><tr><td style="text-align:left">C</td><td style="text-align:left">160ms</td></tr><tr><td style="text-align:left">PyPy</td><td style="text-align:left">124.16ms</td></tr><tr><td style="text-align:left">Python</td><td style="text-align:left">5102.14ms</td></tr><tr><td style="text-align:left">Golang</td><td style="text-align:left">20.50ms</td></tr></tbody></table><p>结论：从测试结果来看，执行效率Golang &gt; PyPy &gt; C &gt; Python <br><br>分析：<br><br>Golang是编译型语言，会将代码编译成二进制可执行机器码。我们来分析执行Golang的执行时间，我们知道一个汇编指令至少执行一个CPU周期（指令执行整数个周期，大部分指令执行一个周期，指令具体执行周期可以参考CPU手册）。也就是说只要我们知道执行整个程序的汇编指令数量，我们就能对程序运行时间做出评判。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">测试用例循环体内执行以下操作，大致翻译成汇编指令，统计汇编指令数目</span><br><span class="line">1. i &lt; N --&gt; 将i、N入栈，cmp后比较结果来做Jmp操作，大约5条汇编指令；</span><br><span class="line">2. j += 1 --&gt; 将j入栈，执行Inc操作，然后保存到j，大约3条汇编指令；</span><br><span class="line">3. i ++ --&gt; 将i入栈，执行Inc，保存到i，大约3条汇编；</span><br><span class="line">4. 还有一个隐藏的Jump到操作1的操作， 1条汇编</span><br><span class="line"></span><br><span class="line">故一个循环体总体汇编指令条目为(5+3+3+1)=12条</span><br></pre></td></tr></table></figure></p><p>CPU主频为3.30GHZ，循环体汇编条目约为12条。我们以CPU满载、每条指令一个周期计算，执行<code>2&lt;&lt;25</code>次循环体需要用时=1000 <em> ((2&lt;&lt;25) </em> 12) / (3.3 * (10**9)) = 244.03ms。<br>而我们测试Golang用时20.50ms，为什么Golang比前面计算的244.03ms远远要小？秘密在于CPU的指令流水线，根据资料我们知道Intel CPU是14级流水线架构，也就是说一个CPU周期最大可执行14条汇编指令。我们用单级流水线理论时间除以Golang用时：244.03ms / 20.50ms = 11.9，考虑多CPU周期汇编指令的存在和系统调度消耗，14是我们理论上限值，可见结果符合预期。</p><p>Golang在这个测试用例中比C语言更快，更是秒杀Python，超乎预期。通过计算发现Golang的计算效率接近CPU的极限，着实是一门高效的编译型语言。</p><p>另外，附上常见的Benchmark连接<a href="http://benchmarksgame.alioth.debian.org/u64q/task-descriptions.html" target="_blank" rel="noopener">The Computer Language<br>Benchmarks Game</a>，可对比各种语言的性能情况</p><p>参考资料：<br><br><a href="https://zh.wikipedia.org/wiki/Core%E5%BE%AE%E6%9E%B6%E6%A7%8B" target="_blank" rel="noopener">Core微架构-14级流水线</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文测试Go、Python、PyPy、C的效率，作为学习Go的参考标准。测试用例：进行(2&amp;lt;&amp;lt;25)次简单加法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;测试环境：&lt;br&gt;&lt;br&gt;系统：Windows7 专业版&lt;br&gt;&lt;br&gt;CPU：Intel(R) Core(T
      
    
    </summary>
    
    
  </entry>
  
</feed>
