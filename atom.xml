<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LiangIter</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liangiter.top/"/>
  <updated>2019-09-28T07:02:03.082Z</updated>
  <id>http://liangiter.top/</id>
  
  <author>
    <name>LiangIter</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>肯耐珂萨-职场情商修炼</title>
    <link href="http://liangiter.top/2019/09/28/%E8%82%AF%E8%80%90%E7%8F%82%E8%90%A8-%E8%81%8C%E5%9C%BA%E6%83%85%E5%95%86%E4%BF%AE%E7%82%BC/"/>
    <id>http://liangiter.top/2019/09/28/肯耐珂萨-职场情商修炼/</id>
    <published>2019-09-28T06:03:09.000Z</published>
    <updated>2019-09-28T07:02:03.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="情商要素"><a href="#情商要素" class="headerlink" title="情商要素"></a>情商要素</h2><ol><li>情绪自觉</li><li>人际关系</li><li>同理心</li><li>责任感</li><li>现实判断</li><li>冲动控制</li><li>压力管理</li><li>乐观</li></ol><h2 id="沟通漏斗"><a href="#沟通漏斗" class="headerlink" title="沟通漏斗"></a>沟通漏斗</h2><ol><li>第一层： 心里想的</li><li>第二层： 说出来的</li><li>第三层：对象听到的</li><li>第四层： 对方理解的</li><li>第五层： 行为产生</li></ol><h2 id="跨部门沟通的常见现象"><a href="#跨部门沟通的常见现象" class="headerlink" title="跨部门沟通的常见现象"></a>跨部门沟通的常见现象</h2><ol><li>关闭频道<br>现象：没有在接受信息<br><br>原因：内心地处，与自己无关<br><br>影响：不欢而散<br></li><li>争夺频道<br>现象：打断<br><br>原因：意见不统一<br><br>影响：争论、争执、争吵<br></li><li>分叉频道<br>现象：无语<br><br>原因：理解不一致<br><br>影响：效率低下<br></li></ol><h2 id="跨部门沟通中如何“调频”"><a href="#跨部门沟通中如何“调频”" class="headerlink" title="跨部门沟通中如何“调频”"></a>跨部门沟通中如何“调频”</h2><ul><li>了解和表达对方的需求</li><li>合理的提问</li><li>给与适当的肯定</li></ul><h3 id="同理心的三个维度"><a href="#同理心的三个维度" class="headerlink" title="同理心的三个维度"></a>同理心的三个维度</h3><ul><li>换位思考</li><li>认同对方的情感</li><li>主动找出对方所关心或顾虑</li></ul><h3 id="同理心的自我锻炼"><a href="#同理心的自我锻炼" class="headerlink" title="同理心的自我锻炼"></a>同理心的自我锻炼</h3><ul><li>当对方交办一项工作时，从对方的角度来理解这个工作</li><li>激励他人时，了解对方信息需求，找准“兴奋点”</li><li>批评他人时，照顾对方的面子、自尊，不揭伤疤</li><li>与他人合作时，先理解对方的观点，看问题的角度，再介绍自己的想法</li></ul><h2 id="人际关系"><a href="#人际关系" class="headerlink" title="人际关系"></a>人际关系</h2><h3 id="何为人际关系"><a href="#何为人际关系" class="headerlink" title="何为人际关系"></a>何为人际关系</h3><ul><li>信任</li><li>关心</li><li>互相满意</li></ul><h3 id="职场中“高人际”的四个特点"><a href="#职场中“高人际”的四个特点" class="headerlink" title="职场中“高人际”的四个特点"></a>职场中“高人际”的四个特点</h3><ol><li>从对方角度看问题，尽力满足对方需求</li><li>有相互满意的人际关系</li><li>贡献自己的所能</li><li>需要帮助时也会提出并乐于接受帮助</li></ol><h3 id="职场中如何发展和维系人际关系"><a href="#职场中如何发展和维系人际关系" class="headerlink" title="职场中如何发展和维系人际关系"></a>职场中如何发展和维系人际关系</h3><ol><li>会议上多介绍自己的工作</li><li>多支持他人的工作</li><li>多请人来支援你的工作</li><li>分享工作中所有的信息</li><li>参加公司的内外活动</li><li>保持同理心</li></ol><h2 id="现实判断"><a href="#现实判断" class="headerlink" title="现实判断"></a>现实判断</h2><h3 id="为何现实判断"><a href="#为何现实判断" class="headerlink" title="为何现实判断"></a>为何现实判断</h3><p>评价自己感受到的体验和客观存在的事物之间的一致性</p><ul><li>客观的区分内心世界的思想（情感）和外部世界的能力（过程）</li><li>看到客观存在着的显示，而不是我们希望的显示或是害怕的现实</li></ul><h3 id="现实判断常见的六大误区"><a href="#现实判断常见的六大误区" class="headerlink" title="现实判断常见的六大误区"></a>现实判断常见的六大误区</h3><ol><li>灾难化</li><li>自利偏见</li><li>证实偏误</li><li>晕轮效应</li><li>刻板印象偏误</li><li>沉没成本悖论</li></ol><h3 id="如何正确现实判断"><a href="#如何正确现实判断" class="headerlink" title="如何正确现实判断"></a>如何正确现实判断</h3><ul><li>放弃第一印象总是对的的观念</li><li>避免非黑即白的思维</li><li>听取过来人的意见</li><li>区别事实、评价、推论</li></ul><h2 id="冲动"><a href="#冲动" class="headerlink" title="冲动"></a>冲动</h2><h3 id="控制冲动"><a href="#控制冲动" class="headerlink" title="控制冲动"></a>控制冲动</h3><p>ABCDE法则， A诱发事件-&gt;B想法-&gt;C情绪行为, 质疑B，从而避免坏的情绪行为C，产生新的结果E<br><img src="/2019/09/28/肯耐珂萨-职场情商修炼/abcde.jpg" alt="imag"></p><h3 id="控制冲动“四步法”"><a href="#控制冲动“四步法”" class="headerlink" title="控制冲动“四步法”"></a>控制冲动“四步法”</h3><ol><li>意识到并接受自己的情绪</li><li>弄清情绪真正产生的原因</li><li>做出愤怒的反应前，停一下6s</li><li>ABCDE法则</li></ol><h2 id="压力"><a href="#压力" class="headerlink" title="压力"></a>压力</h2><ul><li>由于自己能动用的资源无法满足工作和自身要求时所感受到的焦虑状态</li><li>压力的大小既取决于压力源的大小，又取决于承担压力的对象强弱程度</li></ul><h3 id="留个压力征兆"><a href="#留个压力征兆" class="headerlink" title="留个压力征兆"></a>留个压力征兆</h3><ul><li>低迷</li><li>易愤怒</li><li>焦虑不安</li><li>思维中断</li><li>借口多</li><li>注意力不集中</li></ul><h3 id="压力曲线"><a href="#压力曲线" class="headerlink" title="压力曲线"></a>压力曲线</h3><p>适当的压力有助于提高绩效<br><img src="/2019/09/28/肯耐珂萨-职场情商修炼/pressure.jpeg" alt="imag"></p><h3 id="预警“P点”做好自我管理"><a href="#预警“P点”做好自我管理" class="headerlink" title="预警“P点”做好自我管理"></a>预警“P点”做好自我管理</h3><p>捕捉P点常见信号</p><ul><li>再也忍受不了了</li><li>没有办法面对</li><li>怎样才能摆脱</li><li>难道别人就不能帮帮我吗</li></ul><p>P点不宜做的行为</p><ul><li>凡事拖拉</li><li>把压力发泄到其他人身上</li><li>沉迷电脑电视 </li><li>酗酒</li><li>睡眠过渡</li></ul><p>P点应该做的行为</p><ol><li>写上自己面对的所有问题</li><li>把相关压力归类</li><li>从小问题逐步解决</li></ol><h3 id="有效的解压行为"><a href="#有效的解压行为" class="headerlink" title="有效的解压行为"></a>有效的解压行为</h3><ol><li>良好的自我肯定</li><li>压力下做最好的自己</li><li>有规律的运动</li></ol><h3 id="如何保持乐观"><a href="#如何保持乐观" class="headerlink" title="如何保持乐观"></a>如何保持乐观</h3><ol><li>相信事件最终能够解决的</li><li>积极想象成功的画面</li><li>多留意好的一面</li><li>避免灾难化思考</li></ol><p>OVER</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;情商要素&quot;&gt;&lt;a href=&quot;#情商要素&quot; class=&quot;headerlink&quot; title=&quot;情商要素&quot;&gt;&lt;/a&gt;情商要素&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;情绪自觉&lt;/li&gt;
&lt;li&gt;人际关系&lt;/li&gt;
&lt;li&gt;同理心&lt;/li&gt;
&lt;li&gt;责任感&lt;/li&gt;
&lt;li&gt;现实
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>直播广告翻车记</title>
    <link href="http://liangiter.top/2019/09/23/%E7%9B%B4%E6%92%AD%E5%B9%BF%E5%91%8A%E7%BF%BB%E8%BD%A6%E8%AE%B0/"/>
    <id>http://liangiter.top/2019/09/23/直播广告翻车记/</id>
    <published>2019-09-23T13:56:11.000Z</published>
    <updated>2019-09-23T13:57:57.944Z</updated>
    
    <content type="html"><![CDATA[<p>关键词：redis slave spire 获取过期数据</p><blockquote><p>周六晚会直播，有人反馈观看过广告后，再也不能触发广告了。第一次值班守护直播，就像守护女朋友一样，小心翼翼胆战心惊如履薄冰，怎奈还是翻船了。<br>话不多说，这锅我背了，快去找到原因解决问题吧。经过一番努力并没有头绪，经过项目组踩过坑的同事查证，redis cluster readonly=1， 导致了读取slave 过期expire数据的bug；<br>广告播放后，同一个用户接下来10分钟内不会再出广告。广告播放的标记存储在redis中，expire设置为600，按理10分钟后标记清除，广告系统获取不到播放标记会给用户再次下发广告。当晚有一些用户看过第一广告后，长时间无法第二次播放广告。经过查询相应用户后台日志，发现问题确实是10分钟不重复观看策略导致的。</p></blockquote><p>也就是说redis存在expire过期数据仍可被读取的情况。<br><br>经过一番查证，redis曾发起Issue <a href="https://github.com/antirez/redis/issues/1768" target="_blank" rel="noopener">Improve expire consistency on slaves</a>，以下摘录说明了这个情况（坑呀，宝宝心里苦%&gt;_&lt;%）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In order <span class="keyword">for</span> Redis to ensure consistency between a master <span class="keyword">and</span> its slaves, eviction of keys </span><br><span class="line">with an expire are managed by the master, which sends an <span class="keyword">explicit</span> DEL to its slaves when </span><br><span class="line">the key gets actually removed.</span><br><span class="line">This means that slaves are <span class="keyword">not</span> able to directly expire keys, even <span class="keyword">if</span> these keys are </span><br><span class="line">logically expired on the master side. So a GET that will <span class="keyword">return</span> null in the master side, </span><br><span class="line">may <span class="keyword">return</span> a stale value in the slave side.</span><br><span class="line">为了保证redis主、从一致性，expire数据的删除由master来进行，当expire数据删除的时候，</span><br><span class="line">master会向slave发送删除命令这意味着，即使这些expire数据从逻辑上应该被master端删除，</span><br><span class="line">slaves也不会直接删除expire数据。在master获取这些过期数据将会获取null，</span><br><span class="line">而在slave端可能仍能获取到旧的数据</span><br></pre></td></tr></table></figure><p>凭什么认定我们是读取的从库呢？<br>翻出武功秘籍，对项目用到的golang redis.v5源码进行分析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ClusterClient)</span> <span class="title">cmdSlotAndNode</span><span class="params">(state *clusterState, cmd Cmder)</span> <span class="params">(<span class="keyword">int</span>, *clusterNode, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> state == <span class="literal">nil</span> &#123;</span><br><span class="line">node, err := c.nodes.Random()</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, node, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cmdInfo := c.cmds[cmd.name()]</span><br><span class="line">firstKey := cmd.arg(cmdFirstKeyPos(cmd, cmdInfo))</span><br><span class="line">slot := hashtag.Slot(firstKey)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> cmdInfo != <span class="literal">nil</span> &amp;&amp; cmdInfo.ReadOnly &amp;&amp; c.opt.ReadOnly &#123;</span><br><span class="line"><span class="keyword">if</span> c.opt.RouteByLatency &#123;</span><br><span class="line">node, err := state.slotClosestNode(slot)</span><br><span class="line"><span class="keyword">return</span> slot, node, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node, err := state.slotSlaveNode(slot)</span><br><span class="line"><span class="keyword">return</span> slot, node, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node, err := state.slotMasterNode(slot)</span><br><span class="line"><span class="keyword">return</span> slot, node, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>redis cluster的readonly字段配置为1的情况下，c.opt.ReadOnly条件成立，会使用slaveNode，反过来则使用masterNode，而使用slaveNode则可能引发上面的问题。</p><h4 id="为什么我们测试的时候没有发现这个问题"><a href="#为什么我们测试的时候没有发现这个问题" class="headerlink" title="为什么我们测试的时候没有发现这个问题"></a>为什么我们测试的时候没有发现这个问题</h4><p>话说我们也有测试过，几个人没有出现这个问题，脸黑吗(⊙o⊙)<br>找啊找，低版本Redis expire过期的策略<a href="https://redis.io/commands/expire#how-redis-expires-keys" target="_blank" rel="noopener">在这里</a>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">How Redis expires keys</span><br><span class="line">Redis keys are expired in two ways: a passive way, <span class="keyword">and</span> an active way.</span><br><span class="line">A key is passively expired simply when some client tries to access it, </span><br><span class="line"><span class="keyword">and</span> the key is found to be timed out.</span><br><span class="line">Of course <span class="keyword">this</span> is <span class="keyword">not</span> enough as there are expired keys that will never </span><br><span class="line">be accessed again. These keys should be expired anyway, so periodically </span><br><span class="line">Redis tests a few keys at random among keys with an expire <span class="built_in">set</span>. All the </span><br><span class="line">keys that are already expired are deleted from the keyspace.</span><br><span class="line"></span><br><span class="line">Specifically <span class="keyword">this</span> is what Redis does <span class="number">10</span> times per second:</span><br><span class="line"><span class="number">1.</span> Test <span class="number">20</span> random keys from the <span class="built_in">set</span> of keys with an associated expire.</span><br><span class="line"><span class="number">2.</span> Delete all the keys found expired.</span><br><span class="line"><span class="number">3.</span> If more than <span class="number">25</span>% of keys were expired, start again from step <span class="number">1.</span></span><br><span class="line">This is a trivial probabilistic algorithm, basically the assumption is </span><br><span class="line">that our sample is representative of the whole key space, </span><br><span class="line"><span class="keyword">and</span> we <span class="keyword">continue</span> to expire until the percentage of keys that are likely </span><br><span class="line">to be expired is under <span class="number">25</span>%</span><br><span class="line"></span><br><span class="line">Redis如何过期密钥</span><br><span class="line">Redis密钥以两种方式过期：被动方式和主动方式。</span><br><span class="line">当某个客户端尝试访问密钥时，密钥被动过期，并且发现密钥超时。</span><br><span class="line">当然这还不够，因为有过期的密钥永远不会被再次访问。这些密钥无论如何都应该过期，</span><br><span class="line">所以周期性地Redis会在具有过期集的密钥中随机测试几个密钥。已经过期的</span><br><span class="line">所有密钥都将从密钥空间中删除。</span><br><span class="line">具体来说，这就是Redis每秒做<span class="number">10</span>次的事情：</span><br><span class="line"><span class="number">1.</span> 从具有相关过期的密钥集中测试<span class="number">20</span>个随机密钥。</span><br><span class="line"><span class="number">2.</span> 删除找到的所有密钥已过期。</span><br><span class="line"><span class="number">3.</span> 如果超过<span class="number">25</span>％的密钥已过期，请从步骤<span class="number">1</span>重新开始。</span><br><span class="line">这是一个简单的概率算法，基本上假设我们的样本代表整个密钥空间，</span><br><span class="line">我们继续到期，直到可能过期的密钥百分比低于<span class="number">25</span>％</span><br></pre></td></tr></table></figure><p>从以上信息可以归纳出：</p><ol><li>测试的时候，QPS小，Redis主动过期策略1s内可以清楚10*20=200个已过期的key，完全能处理测试好测试时候的expire key；</li><li>到了正式上线，QPS增大，整体上会保留25%已过期的expire key，这也可以解释为什么有些人可以重复看到广告，有些人不可以；<br>这种带有随机性质的问题，通常定位起来都会困难一些，脸确实有点黑O__O </li></ol><h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><ol><li>查看我司服务器redis版本是redis_version:3.0.7-m，这个问题在Redis 3.2 中得到解决，升级大法保平安（万能解决之道，搞不定了，试试升级吧）。</li><li>结合go redis.v5库特性，将readonly字段配置为0，使用masterNode节点。当然，你可以直接连master，就不会有这个问题。但要注意这种方案将会增大master的压力，酌情考虑。</li><li>除此之外也有同学提出了另外的<a href="https://toutiao.io/posts/1884/app_preview" target="_blank" rel="noopener">解决方案</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关键词：redis slave spire 获取过期数据&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;周六晚会直播，有人反馈观看过广告后，再也不能触发广告了。第一次值班守护直播，就像守护女朋友一样，小心翼翼胆战心惊如履薄冰，怎奈还是翻船了。&lt;br&gt;话不多说，这锅我背了，快去找到
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Goland的值与引用类型</title>
    <link href="http://liangiter.top/2019/06/26/Goland%E7%9A%84%E5%80%BC%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>http://liangiter.top/2019/06/26/Goland的值与引用类型/</id>
    <published>2019-06-26T12:37:01.000Z</published>
    <updated>2019-06-26T13:35:03.639Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Goland的值与引用类型"><a href="#Goland的值与引用类型" class="headerlink" title="Goland的值与引用类型"></a>Goland的值与引用类型</h3><blockquote><p>在新的项目中，用到的Goland。以前用Python做项目，Python基本变量的赋值是引用重定向。Goland有些不一样，这里做个测试<br><br>直接利用打印变量值、地址的方式确认变量拷贝情况<br></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getInt</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">i := <span class="number">5</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"in getInt, i"</span>, i, &amp;i)</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intTest</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"in intTest, i"</span>, i, &amp;i)</span><br><span class="line">i = <span class="number">99</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listTest</span><span class="params">(list []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"in listTest, list"</span>, &amp;list, list)</span><br><span class="line">list[<span class="number">0</span>] = <span class="number">99</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapTest</span><span class="params">(mapInt <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"in mapTest, mapInt"</span>, mapInt, &amp;mapInt)</span><br><span class="line">mapInt[<span class="number">99</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">t := <span class="number">1</span></span><br><span class="line">fmt.Println(<span class="string">"in main, t"</span>, t, &amp;t)</span><br><span class="line">t = <span class="number">2</span></span><br><span class="line">fmt.Println(<span class="string">"in main, t"</span>, t, &amp;t)</span><br><span class="line">t = getInt()</span><br><span class="line">fmt.Println(<span class="string">"in main, t"</span>, t, &amp;t)</span><br><span class="line">intTest(t)</span><br><span class="line">fmt.Println(<span class="string">"in main, t"</span>, t, &amp;t)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"*************************"</span>)</span><br><span class="line">l := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"in main, l"</span>, &amp;l, l)</span><br><span class="line">l = []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"in main, l"</span>, &amp;l, l)</span><br><span class="line"></span><br><span class="line">l2 := l</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"in main, l2"</span>, &amp;l2, l2)</span><br><span class="line">listTest(l)</span><br><span class="line">fmt.Println(<span class="string">"in main, l"</span>, l)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"*************************"</span>)</span><br><span class="line">mapInt := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">mapInt[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"in main, mapInt"</span>, mapInt, &amp;mapInt)</span><br><span class="line">mapTest(mapInt)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"in main, mapInt"</span>, mapInt, &amp;mapInt)</span><br><span class="line">fmt.Println(<span class="string">"in main, mapInt"</span>, mapInt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">输出结果</span><br><span class="line">in main, t <span class="number">1</span> <span class="number">0xc0000140a0</span></span><br><span class="line">in main, t <span class="number">2</span> <span class="number">0xc0000140a0</span></span><br><span class="line">in getInt, i <span class="number">5</span> <span class="number">0xc00006ad</span>e0</span><br><span class="line">in main, t <span class="number">5</span> <span class="number">0xc0000140a0</span></span><br><span class="line">in intTest, i <span class="number">5</span> <span class="number">0xc00006ad</span>e8</span><br><span class="line">in main, t <span class="number">5</span> <span class="number">0xc0000140a0</span></span><br><span class="line">*************************</span><br><span class="line">in main, l <span class="number">0xc00006ae58</span> [<span class="number">3</span>/<span class="number">3</span>]<span class="number">0xc000012140</span></span><br><span class="line">in main, l <span class="number">0xc00006ae58</span> [<span class="number">5</span>/<span class="number">5</span>]<span class="number">0xc00001a060</span></span><br><span class="line">in main, l2 <span class="number">0xc00006ae40</span> [<span class="number">5</span>/<span class="number">5</span>]<span class="number">0xc00001a060</span></span><br><span class="line">in listTest, list <span class="number">0xc00006ae28</span> [<span class="number">5</span>/<span class="number">5</span>]<span class="number">0xc00001a060</span></span><br><span class="line">in main, l [<span class="number">99</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">*************************</span><br><span class="line">in main, mapInt <span class="number">0xc00006adf</span>0 <span class="number">0xc000062180</span></span><br><span class="line">in mapTest, mapInt <span class="number">0xc00006adf</span>8 <span class="number">0xc000062180</span></span><br><span class="line">in main, mapInt <span class="number">0xc00006adf</span>0 <span class="number">0xc000062180</span></span><br><span class="line">in main, mapInt <span class="keyword">map</span>[<span class="number">1</span>:<span class="number">2</span> <span class="number">99</span>:<span class="number">100</span>]</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>先看第一组结果，简单int变量t，重新赋值为2后，在内存中的地址不变。与Python不同，Python简单对象赋值是引用重定向，引用一个新的对象，会改变id(obj)的结果。Goland是在原对象的基础上修改，改变原对象中的内容。函数的传参、返回值都会拷贝一个新对象，修改拷贝的对象不影响原对象。</p><p>再看第二组结果，切片类型l，打印第一个数值是变量地址，后面接的是[len/cap]数组内存地址，切片独享保留着对数组内存地址的引用。第二次对切片赋值，同样的对象地址不变，其len、cap、数组地址发生变化。在函数listTest中，形参同样会生成一个新的对象，切片拷贝对象的len、cap、数组内存地址与元对象一致，如果改变拷贝切片中的元素，由于其引用同一个连续数组内存，原对象上也会得到体现，最后main中l[0]=99<br></p><p>再看第三组结果，map类型，打印的第一个值是map变量的地址，第二个参数是map对象引用的数据块地址。同样的，map对象作为形参，会拷贝出一个新对象，与list类似，新老对象引用的数据块地址一致，修改拷贝对象数据块中的数据，会影响老对象的数据。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>Goland对存在的对象重新赋值，会改变原对象内存中的数据，与Python引用重定向相区别</li><li>Goland中slices、map、channel为引用类型，其余简单类型为值类型，值类型对象中空间中包含了对象所需的全部内容，引用类型除了基本信息外还引用着一块可以共享的数据块</li><li>Goland对象作为函数参数、函数返回值、对象间赋值、copy等机制会从老对象拷贝出一个新的对象。这里是浅拷贝机制，值类型完全复制，共用引用数据块，复制引用地址。</li><li><strong>修改拷贝对象时，拷贝对象是引用类型，且修改的是引用数据块中的数据，会影响所有引用该数据块引用对象</strong>，这里容易出bug。</li><li>深拷贝可考虑序列化、反序列化来实现，深拷贝都比较耗时，非必须不建议使用</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Goland的值与引用类型&quot;&gt;&lt;a href=&quot;#Goland的值与引用类型&quot; class=&quot;headerlink&quot; title=&quot;Goland的值与引用类型&quot;&gt;&lt;/a&gt;Goland的值与引用类型&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在新的项目中，用到的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>通用技术总结</title>
    <link href="http://liangiter.top/2018/11/10/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    <id>http://liangiter.top/2018/11/10/通用技术总结/</id>
    <published>2018-11-10T07:55:50.188Z</published>
    <updated>2018-09-27T01:12:52.292Z</updated>
    
    <content type="html"><![CDATA[<p>选择一门技术，要综合考量技术的多个方面来评估。大方向上首先考虑<code>技术综合面</code>：</p><ol><li>业界是否有知名的成功案例；</li><li>是否有强大后援；</li><li>是否有活跃的开发者论坛；</li></ol><p>业界有知名成功案例意味着该技术通过了技术人员的考究，经过了工程的检验，坑也会相对较少。<br>比如Java有Sun，Golang有Google，有这些实力雄厚的公司或机构做背书，有理由相信这些技术未来的潜力；<br>java、python有活跃的论坛，有丰富开源库，做网络应用、缓存、爬虫等工作都有现成的库，无需造轮，大大提高开发效率。另外，有活跃的开发者论坛意味着技术资料比较丰富，并且绝大部分你遇到的问题都有前人遇到过，可以大大减少爬坑的时间。</p><p>业务需求会对系统有一些要求，根据业务特点考虑以下问题：</p><ol><li>计算密集型、IO密集型：计算密集型与IO密集型的任务会对系统有不同的要求；计算密集型任务可以考虑编译型语言、多核&amp;多机（分布式）来实现。多核IO密集型任务并没有什么帮助，多路复用会有好的效果。</li><li>读写频率：不同的读写频率有不同适用的数据结构和算法，会衍生出不同的系统架构；</li><li>系统实时性要求：实时性要求高的系统需要快速响应，服务线程需要避免长时间堵塞式的调用，可以利用并行、分时、多路复用等特性；</li><li>系统安全性要求：服务器连续运行时间要求、数据一致性要求，分布式系统需要考虑CAP问题；</li><li>热更新、热部署：在虚拟机中运行的脚本语言更适合热部署；</li><li>平衡开发效率与运行效率：一般而言抽象层次较高的脚本语言开发效率较高，但运行效率较差；封装程度较低的编译型语言运行效率较高，但开发效率较差；</li><li><code>技术综合面</code>：参考本文前面的对<code>技术综合面</code>的说明；</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;选择一门技术，要综合考量技术的多个方面来评估。大方向上首先考虑&lt;code&gt;技术综合面&lt;/code&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;业界是否有知名的成功案例；&lt;/li&gt;
&lt;li&gt;是否有强大后援；&lt;/li&gt;
&lt;li&gt;是否有活跃的开发者论坛；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;业界有知名
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>垃圾回收机制</title>
    <link href="http://liangiter.top/2018/11/10/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://liangiter.top/2018/11/10/垃圾回收机制/</id>
    <published>2018-11-10T07:55:50.149Z</published>
    <updated>2019-09-28T06:57:02.096Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>近期公司技术分享讲座十分火热，近期我做了有关垃圾回收机制的分享，整理一下文档</p></blockquote><h3 id="垃圾回收背景"><a href="#垃圾回收背景" class="headerlink" title="垃圾回收背景"></a>垃圾回收背景</h3><blockquote><p>John McCarthy 身为 Lisp 之父和人工智能之父，同时，他也是 GC 之父。1960 年，他在其论文中首次发布了 GC 算法（其实是委婉的提出😂）。而 Java 的前身 Oak 是在 1990 发布的，利用 JVM 实现了跨平台。GC 因此一举成名。</p></blockquote><h3 id="垃圾回收基本概念"><a href="#垃圾回收基本概念" class="headerlink" title="垃圾回收基本概念"></a>垃圾回收基本概念</h3><p>基本概念:</p><ul><li>全集</li><li>根集</li><li>可达到的对象集合</li><li>不可达到的对象集合</li></ul><h4 id="垃圾的定义"><a href="#垃圾的定义" class="headerlink" title="垃圾的定义"></a>垃圾的定义</h4><p>引用《垃圾回收的算法与实现》书中的话:</p><blockquote><p>把分配到堆中那些不能通过程序引用的对象称为非活动对象，也就是死掉的对象，我们称为“垃圾”。</p></blockquote><ul><li>程序无法访问的对象</li><li>GC 收集器需要能正确找到垃圾对象并销毁之</li></ul><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>因为我们期望让内存管理变得自动（只管用内存，不管内存的回收），我们就必须做两件事情：</p><blockquote><p>找到内存空间里的垃圾回收垃圾，让程序员能再次利用这部分空间 [1] 只要满足这两项功能的程序，就是 GC，不论它是在 JVM 中，还是在 Ruby 的 VM 中。但这只是两个需求，并没有说明 GC 应该何时找垃圾，何时回收垃圾等等更具体的问题，各类 GC 算法就是在这些更具体问题的处理方式上施展手脚。</p></blockquote><h4 id="全集"><a href="#全集" class="headerlink" title="全集"></a>全集</h4><ul><li>进程内存中全部对象的集合</li><li>以 Python 为例:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gc.get_objects()</span><br></pre></td></tr></table></figure><h4 id="根集"><a href="#根集" class="headerlink" title="根集"></a>根集</h4><ul><li>不用通过引用关系,可以直接访问对象的集合</li></ul><h4 id="可达对象集合"><a href="#可达对象集合" class="headerlink" title="可达对象集合"></a>可达对象集合</h4><ul><li>根集的对象</li><li>通过可达对象,利用引用关系遍历到的所有对象<br><img src="/2018/11/10/垃圾回收机制/reachable.png" alt="imag"></li></ul><h4 id="不可达到的对象集合"><a href="#不可达到的对象集合" class="headerlink" title="不可达到的对象集合"></a>不可达到的对象集合</h4><ul><li>全集与可达对象集合差集</li><li>不可达对象是垃圾</li><li>Python 中 gc.collect()后垃圾存在列表 gc.grabage 中</li></ul><h4 id="垃圾回收的优点"><a href="#垃圾回收的优点" class="headerlink" title="垃圾回收的优点"></a>垃圾回收的优点</h4><ul><li>提高编程效率</li><li>避免内存泄漏</li><li>野指针 (悬垂指针)</li><li>释放错误的内存</li></ul><blockquote><p>内存泄露：忘记释放了某一部分内存，会导致那部分内存不可用，并占用总的内存空间。如果这一现象持续发生，会引起内存被占满，系统崩溃悬垂指针：忘记初始化指向释放了的内存的指针。这会导致再次调用指针时，该指针指向空内存，引起 bug 释放错误的内存：人为的操作难免会发生错误，如果释放了错误的内存，也会导致程序发生莫名其妙的 bug</p></blockquote><blockquote><p>由此可见垃圾回收的重要性，既可以减少程序员的工作量，更重要的是可以避免很多不必要的错误。</p></blockquote><h4 id="垃圾回收缺点"><a href="#垃圾回收缺点" class="headerlink" title="垃圾回收缺点"></a>垃圾回收缺点</h4><ul><li>垃圾回收消耗cpu，影响程序性能</li></ul><h4 id="垃圾回收性能评价"><a href="#垃圾回收性能评价" class="headerlink" title="垃圾回收性能评价"></a>垃圾回收性能评价</h4><ul><li>垃圾回收总时间</li><li>进程突然的停顿</li><li>空间利用 —— 减少内存碎片 - 空间连续性、时间连续性</li><li>以上要求互相制衡，需要折中</li></ul><h3 id="主流垃圾回收策略"><a href="#主流垃圾回收策略" class="headerlink" title="主流垃圾回收策略"></a>主流垃圾回收策略</h3><p>John McCarthy 身为 Lisp 之父和人工智能之父，同时，他也是 GC 之父。1960 年，他在其论文中首次发布了 GC 算法（其实是委婉的提出😂）。</p><p>标记-清除算法 由 John McCarthy 在 1960 年提出 引用计数法 由 George E. Collins 在 1960 年提出 此算法会有循环引用问题，Harold McBeth 1963 年指出。 复制算法 由 Marvin L. Minsky 在 1963 年提出</p><p>《垃圾回收》的作者认为：</p><blockquote><p>从 50 年前 GC 算法首次发布以来，众多研究者对其进行了各种各样的研究，因此许多 GC 算法也得以发布。[2] 但事实上，这些算法只不过是把前文中提到的三种算法进行组合或应用。也可以这么说，1963 年 GC 复制算法诞生时，GC 的根本性内容就已经完成了。</p></blockquote><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>垃圾回收关注的是对于不会再次被使用的对象的内存回收，换一种说法，对于会被垃圾回收清理的对象（内存），不会再次的被其他对象引用。那么可以为每一个对象引入一个计数器，对于任意一个对象，每有一次对这个对象的引用，就将计数器加 1；结束对这个对象的引用，再将计数器减 1；一旦计数器归 0，则表示这个对象可以被清除。这就是引用计数法。</p><p>由于在计数器归 0 后，可以立即知道这个对象成为了垃圾，所以引用计数法有着即使回收的优点。同样，这个算法也不是完美的，存在着一定的缺点：</p><ul><li>占用资源：因为每个对象都需要维护一个计数器，每次指针有更新都伴随着计数器的更新，一定程度上占用了计算资源</li><li>占用内存：计数器需要占用一定的内存，为了安全起见，计数器值的上限要大于所有对象的上限，这也是一笔不小的开销</li><li>实现复杂：虽然引用计数的思想简单，但是实现起来却不那么容易。各位可以思考下，如果自己编写这一算法，该如何实现？</li><li>无法解决循环引用：就像会有狗狗喜欢咬自己的尾巴，把自己咬成环，对象也会存在循环的引用。假设两个对象 a 和 b，a 有指向 b 的指针，b 有指向 a 的指针。二者可能一起成为垃圾，一旦这种情况发生，由于存在对对方的引用，它们的计数器永远都不会归 0，它们也不会被回收</li></ul><h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p>正如算法的名字，标记清除法可以划分成两个阶段，标记和清除：</p><ul><li>标记</li><li><ul><li>标记根集中的所有对象为可达</li></ul></li><li><ul><li>从根集中的对象遍历，将其引用的对象标记为可达</li></ul></li><li><ul><li>迭代第二步，找到所有可达对象</li></ul></li><li><p>清除</p></li><li><ul><li>全集与可达对象集合的差集，标记为不可达对象集合</li></ul></li><li><ul><li>销毁所有不可达对象</li></ul></li></ul><p><img src="/2018/11/10/垃圾回收机制/ref_count.png" alt="imag"></p><p>优点</p><ul><li>思路简单，实现简单，是这个算法的一大优点.</li><li>没有额外内存开销</li><li>可以正确销毁循环引用的对象</li></ul><p>缺点</p><p>简单也意味着在其他部分有所牺牲，从上图我们可以看出一些端倪：碎片化：由于只是将垃圾对象清除掉，对于存活对象不做处理，所以由于存活对象分布的不连续性，会导致可用内存被分割成一块块的。如果有一个新的对象请求内存，需要去内存中寻找，哪一个空闲块（可用一个链表来维护空闲块的位置）足够满足这个对象的需求。更极端的情况，空闲的总内存大于对象请求的空间，却没有足够的连续空闲空间，来完成内存的分配。与写时复制技术不兼容：写时复制（Copy On Write）是一个很重要的思想，可以优化内存占用或者提升并发环境下的性能。顾名思义，这一技术是在有写入的时候，对内存进行复制，以达到一定的优化目的。而标记清除算法的标记过程，就是一次对内存（对象头）的写入，会不断地引起内存复制。因此标记清除算法与此技术并不互相兼容</p><ul><li>标记-清除操作时间消耗较大，程序会顿卡</li><li>对象不可达后，销毁有延时</li></ul><p><img src="/2018/11/10/垃圾回收机制/ref_count2.png" alt="imag"></p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>在复制算法中，先将内存分为两个部分，From 区和 To 区，两部分大小相等。对象分配时，只会在 From 区进行分配。复制算法可以分两步，第一步为类似标记清除算法的标记，在 From 区中，找出所有活动的对象。区别在于第二步。复制算法会把这些活动的对象，复制到 To 区中，再将原有的 From 区全部清空，并交换两部分内存的职责，即一次 GC 后，原有的 From 区会成为 To 区，To 区相反。</p><p><img src="/2018/11/10/垃圾回收机制/copy.png" alt="imag"></p><p>优点<br>复制算法的优点相比于另外两个算法还是多一些的：</p><p>效率快：相比于标记清除算法，复制算法在标记阶段，只需要标记哪些对象是活动的就可以了，相比于标记清除算法需要遍历所有的对象，性能上有提升不会发生碎片化：同样相比于标记清除算法，由于存活下来的对象会在 To 区中连续的分配，因此不会像标记清除算法那样，需要维护碎片空间分配速度快：由于不会发生碎片化，如果有一个新的对象请求内存，那么分配时可以直接追加在 From 区已用内存之后，分配的速度快.</p><p>缺点<br>同样复制算法也不是十全十美，它也有着如下的缺点：内存使用率低：由于复制算法把内存分成了两块，那么对于对象的可用空间来说，仅仅是其他算法的一半自对象的递归复制：一个对象通常会关联一些自对象。在复制这些对象的时候，还需要递归的去处理它的自对象，这通常会产生一定的开销。同时，在递归调用时，存在着函数栈的消耗，潜藏着栈溢出的风险</p><h4 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h4><ul><li>不可到达对象在内存中是分散的，回收对象后，空闲内存是分段的</li><li>移动可到达的堆对象，保持内存连续<br><img src="/2018/11/10/垃圾回收机制/relocate.png" alt="imag"></li></ul><h4 id="分代算法"><a href="#分代算法" class="headerlink" title="分代算法"></a>分代算法</h4><ul><li>销毁的总是年轻的对象<br>— 统计表明：80%-90%新分配的对象会在随后几百万条指令周期内销毁</li><li>将堆空间分成几块</li><li>新对象生成在空间1</li><li>当空间1满了，将对象移动到空间2，再往上也如此类推</li><li>空间序号越小，垃圾回收检测越频繁</li><li>Python分为三代，gc.get_threshold可以获取每一代空间的默认阈值</li></ul><h3 id="各语言的垃圾回收策略"><a href="#各语言的垃圾回收策略" class="headerlink" title="各语言的垃圾回收策略"></a>各语言的垃圾回收策略</h3><table><thead><tr><th>Luanguage</th><th>引用计数</th><th>标记-清除</th><th>分代</th><th>重定位</th><th>复制</th></tr></thead><tbody><tr><td>Python</td><td>√</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>JavaScript</td><td>√</td><td>√</td><td></td><td></td><td></td></tr><tr><td>Java</td><td>√</td><td>√</td><td></td><td></td><td>√</td></tr><tr><td>Golang</td><td>√</td><td></td><td></td><td></td><td></td></tr></tbody></table><blockquote><p>1、JavaScript 中 BOM、COM 用的是引用计数机制<br><br>2、Golang 最新用的是三色标记-清除算法，标记阶段需要 STW，清除阶段可以并发进行</p></blockquote><h3 id="Python垃圾回收实战"><a href="#Python垃圾回收实战" class="headerlink" title="Python垃圾回收实战"></a>Python垃圾回收实战</h3><p>以 Python 为例 Python 的 gc.collect() 标记-清除需要消耗一定时间，在对象数量达到百万级别时会有秒级卡顿。有些项目对实时性要求比较高，会调用 gc.disable()关闭 gc；关闭 gc 意味着在开发阶段就要解除所有的循环引用，不然会造成内存泄漏。即使不关闭 gc，在销毁对象时解除循环引用，有利于减少 gc 卡顿时间。那如何找到循环引用的对象？如何找出引用环的情况？</p><blockquote><p>gc.DEBUG_SAVEALL When set, all unreachable objects found will be appended to garbage rather than being freed. This can be useful for debugging a leaking program.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gc.set_debug(gc.DEBUG_SAVEALL)</span><br><span class="line">gc.collect()</span><br><span class="line">print(gc.garbage)</span><br></pre></td></tr></table></figure><p>上面的方法可以找到垃圾对象，但要靠自己去找到对象间的引用情况来解除引用。利用 objgraph 可以找到对象的引用关系链并生成图。但是在实践中，进程中对象数量较大时，objgraph 经常会慢到让人想要原地自爆。也可以自己编写工具，在 gc.garbage 做图的遍历，找到所有的环引用，这样会比较全比较快。(TODO: 待分享通过gc.garbage查环工具代码)<br><img src="/2018/11/10/垃圾回收机制/obj_graph.png" alt="imag"></p><blockquote><p>gc.garbage <br><br>A list of objects which the collector found to be unreachable but could not be freed (uncollectable objects). By default, this list contains only objects with <strong>del</strong>() methods. [1] Objects that have <strong>del</strong>() methods and are part of a reference cycle cause the entire reference cycle to be uncollectable, including objects not necessarily in the cycle but reachable only from it. Python doesn’t collect such cycles automatically because, in general, it isn’t possible for Python to guess a safe order in which to run the <strong>del</strong>() methods. If you know a safe order, you can force the issue by examining the garbage list, and explicitly breaking cycles due to your objects within the list. Note that these objects are kept alive even so by virtue of being in the garbage list, so they should be removed from garbage too. For example, after breaking cycles, do del gc.garbage[:] to empty the list. It’s generally better to avoid the issue by not creating cycles containing objects with <strong>del</strong>() methods, and garbage can be examined in that case to verify that no such cycles are being created.</p></blockquote><blockquote><p>If DEBUG_SAVEALL is set, then all unreachable objects will be added to this list rather than freed.</p></blockquote><p>有个很重要的点，Python2 中，当对象形成环引用，即使开启 gc，实现了<strong>del</strong>方法的对象也无法被回收，因为 gc 并不知道在<strong>del</strong>方法中是否对引用的对象有操作，无法确定正确的回收顺序。在Python 中，一般而言，尽量不要实现<strong>del</strong>方法，而改用其他方法在销毁时手动调用之。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;近期公司技术分享讲座十分火热，近期我做了有关垃圾回收机制的分享，整理一下文档&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;垃圾回收背景&quot;&gt;&lt;a href=&quot;#垃圾回收背景&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收背景&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>十步学习法</title>
    <link href="http://liangiter.top/2018/11/10/%E5%8D%81%E6%AD%A5%E5%AD%A6%E4%B9%A0%E6%B3%95/"/>
    <id>http://liangiter.top/2018/11/10/十步学习法/</id>
    <published>2018-11-10T07:55:50.127Z</published>
    <updated>2018-09-28T06:19:16.916Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在看《软技能：代码之外的生存指南》，作者分享他自己的学习方法——十步学习法。自己感觉平时学习新技术套路大致也是这样，不过自己并没有做过细致的总结和归纳，这里做一个简单的摘录和分享，详细情况可以去阅读原作，作者是一位充满激情、兴趣广泛、热爱生活、热爱思考而小有成就的技术人员，书本与技术有关，而不局限于技术，对任何人都有借鉴意义。</p></blockquote><h2 id="十步学习法"><a href="#十步学习法" class="headerlink" title="十步学习法"></a>十步学习法</h2><h3 id="1-了解全局"><a href="#1-了解全局" class="headerlink" title="1.了解全局"></a>1.了解全局</h3><h3 id="2-确定范围"><a href="#2-确定范围" class="headerlink" title="2.确定范围"></a>2.确定范围</h3><h3 id="3-定义目标"><a href="#3-定义目标" class="headerlink" title="3.定义目标"></a>3.定义目标</h3><h3 id="4-寻找资源"><a href="#4-寻找资源" class="headerlink" title="4.寻找资源"></a>4.寻找资源</h3><h3 id="5-创建学习计划"><a href="#5-创建学习计划" class="headerlink" title="5.创建学习计划"></a>5.创建学习计划</h3><h3 id="6-筛选资源"><a href="#6-筛选资源" class="headerlink" title="6.筛选资源"></a>6.筛选资源</h3><h3 id="7-开始学习，浅尝辄止"><a href="#7-开始学习，浅尝辄止" class="headerlink" title="7.开始学习，浅尝辄止"></a>7.开始学习，浅尝辄止</h3><h3 id="8-动手操作，边学边玩"><a href="#8-动手操作，边学边玩" class="headerlink" title="8.动手操作，边学边玩"></a>8.动手操作，边学边玩</h3><h3 id="9-全面掌握，学以致用"><a href="#9-全面掌握，学以致用" class="headerlink" title="9.全面掌握，学以致用"></a>9.全面掌握，学以致用</h3><h3 id="10-乐为人师，融会贯通"><a href="#10-乐为人师，融会贯通" class="headerlink" title="10.乐为人师，融会贯通"></a>10.乐为人师，融会贯通</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近在看《软技能：代码之外的生存指南》，作者分享他自己的学习方法——十步学习法。自己感觉平时学习新技术套路大致也是这样，不过自己并没有做过细致的总结和归纳，这里做一个简单的摘录和分享，详细情况可以去阅读原作，作者是一位充满激情、兴趣广泛、热爱生活、
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>十亿级别字符串模糊匹配设计与实现</title>
    <link href="http://liangiter.top/2018/11/10/%E5%8D%81%E4%BA%BF%E7%BA%A7%E5%88%AB%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://liangiter.top/2018/11/10/十亿级别字符串模糊匹配设计与实现/</id>
    <published>2018-11-10T07:55:50.111Z</published>
    <updated>2018-09-21T07:42:38.320Z</updated>
    
    <content type="html"><![CDATA[<p>项目用mongodb作为数据库，mongodb支持索引，可对玩家名建立索引快速查找玩家名对应的项。模糊匹配方面，mongodb有提供全文匹配机制，可以用来实现模糊匹配需求。不过mongodb的全文匹配有两个缺点，一是中文版的全文匹配是收费功能，二是mongodb的全文匹配专业性、速度性都不是很成熟。使得项目不得不另外寻找新的实现方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ID = <span class="string">"59e1e6cd5c21ac436052300c"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Name = <span class="string">"玩家名字长度八字"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> sys.getsizeof(Name), sys.getsizeof(ID)</span><br><span class="line"></span><br><span class="line">(<span class="number">49</span>, <span class="number">57</span>)</span><br></pre></td></tr></table></figure><p>考虑利用游戏脚本逻辑来实现，用Python多进程协同组成集群方式来实现。这种方式自由度高、易维护、可控性强，在游戏服务器架构上无需要额外部署新的环境等诸多优点。元数据<code>玩家名， 玩家ID</code>在Python中所占内存约为110Byte，加上建立索引的消耗共占内存约200Byte，十亿玩家的数据量就是200GB。考虑到Python内存利用率低，群集内存消耗过大而放弃用Python脚本逻辑来实现。最后考虑用基于Lucene的全文搜索引擎Elasticsearch来实现这个功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;项目用mongodb作为数据库，mongodb支持索引，可对玩家名建立索引快速查找玩家名对应的项。模糊匹配方面，mongodb有提供全文匹配机制，可以用来实现模糊匹配需求。不过mongodb的全文匹配有两个缺点，一是中文版的全文匹配是收费功能，二是mongodb的全文匹配专
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>游戏全球同服服务器框架</title>
    <link href="http://liangiter.top/2018/11/10/%E5%85%A8%E7%90%83%E5%90%8C%E6%9C%8D%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/"/>
    <id>http://liangiter.top/2018/11/10/全球同服游戏服务器框架/</id>
    <published>2018-11-10T07:55:50.078Z</published>
    <updated>2018-09-21T07:42:17.452Z</updated>
    
    <content type="html"><![CDATA[<p>背景：</p><blockquote><p>最近公司要开发一款全球同服，所有玩家可相互匹配战斗、相互加好友、相互聊天的游戏</p></blockquote><hr><p>服务器需要面临的需求有：</p><ul><li>玩家注册量要支持十亿量级</li><li>玩家在线量要支持千万到亿量级</li><li>所有在线玩家可相互通信</li><li>十亿级别玩家名模糊搜索</li></ul><p>需要支持如此量级的连接，必须要消除服务器进程的单点问题，玩家客户端能够均匀的连接到各个服务器进程上。<br>如果玩家可动态选择连接的进程，轻则面临rpc没有命中、重则引发数据回档问题。玩家根据一定的规则均匀Hash到服务器各个进程中，玩家对应的进程固定，不用担心rpc命中和数据存盘的时序问题。</p><p>对于各种服务，类似好友、战斗匹配而言，都不能出现单点。每种服务都是由多进程协同组成功能集群，功能集群对外提供高并发服务。集群服务进程可以用一致性hash规则来选择。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;背景：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最近公司要开发一款全球同服，所有玩家可相互匹配战斗、相互加好友、相互聊天的游戏&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;服务器需要面临的需求有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;玩家注册量要支持十亿量级&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python内存泄露查询</title>
    <link href="http://liangiter.top/2018/11/10/Python%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%9F%A5%E8%AF%A2/"/>
    <id>http://liangiter.top/2018/11/10/Python内存泄露查询/</id>
    <published>2018-11-10T07:55:50.060Z</published>
    <updated>2018-09-21T07:50:17.995Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">需求背景</span><br><span class="line">最近项目在压力测试期间，进程在运行中内存持续增加，物理内存很快就被消耗殆尽。为了服务器能持久提供服务，需要对内存进行诊断。</span><br><span class="line">本文讨论Python层内存对象的检查，CPython扩展产生的泄露不在本文讨论范围。</span><br></pre></td></tr></table></figure><p>Python垃圾回收机制背景：</p><p>Python利用引用计数进行垃圾回收，当引用为0时，对象会被虚拟机析构内存会被释放。环引用则需要通过 <strong>标记-清除算法</strong>(<code>Mark-Sweep</code>) 来销毁对象。如果对象实现了<strong>del</strong>方法，由于gc无法断定销毁是否会影响<strong>del</strong>的调用，故gc无法处理此类对象而产生垃圾。</p><h4 id="需要处理的异常情况包括："><a href="#需要处理的异常情况包括：" class="headerlink" title="需要处理的异常情况包括："></a>需要处理的异常情况包括：</h4><ul><li><strong>垃圾对象</strong>：gc概念上的垃圾对象</li><li><strong>泄露对象</strong>：对象在逻辑上应该被销毁，但是有外部引用，导致对象没有销毁</li><li><strong>环引用对象</strong>：环引用对象会增加gc的cpu消耗，会延长对象回收时间</li></ul><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ol><li>垃圾对象处理：Python类尽量不要实现<strong>del</strong>方法，用其他机制实现就能避免垃圾对象。</li><li>泄露对象解决：需要对逻辑层面十分了解，能知道如何判断一个对象是否是为逻辑层面应该销毁的对象。一般而言，对象用一个属性来标识是否已销毁，利用<code>gc.getobject</code>遍历对象全集，通过标识进行判断就能找出不正常的对象。利用<code>objgraph.show_chain(objgraph.find_backref_chain(obj, objgraph.is_proper_module))</code>生成引用链，解除异常引用解决问题。</li><li>环引用对象处理：先<code>gc.set_debug(gc.DEBUG_SAVEALL)</code>，然后<code>gc.collect()</code>，再通过对<code>gc.garbage</code>里的对象利用引用关系进<em>DFS</em>遍历，记录所有找到的环。对记录的环引用中的对象，在销毁的时候解除引用即可。</li></ol><h4 id="最后分享Python几个常用的内存调试工具："><a href="#最后分享Python几个常用的内存调试工具：" class="headerlink" title="最后分享Python几个常用的内存调试工具："></a>最后分享Python几个常用的内存调试工具：</h4><ul><li><p><a href="https://pypi.python.org/pypi/memory-tools/1.0.5" target="_blank" rel="noopener">memory-tools</a>模块，summarize_objects()可以统计内存中各个class实例数量和所占内存量，并排序输出。可以通过查看对象数量和内存量来分析异常情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Objects count 3,790</span><br><span class="line">Objects size 833,344</span><br><span class="line"></span><br><span class="line">      Size Count Type</span><br><span class="line">   476,864   296 &lt;type &apos;dict&apos;&gt;</span><br><span class="line">    76,320   954 &lt;type &apos;wrapper_descriptor&apos;&gt;</span><br><span class="line">    64,920   541 &lt;type &apos;function&apos;&gt;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">Count       Size Type</span><br><span class="line">  954     76,320 &lt;type &apos;wrapper_descriptor&apos;&gt;</span><br><span class="line">  541     64,920 &lt;type &apos;function&apos;&gt;</span><br><span class="line">  515     37,080 &lt;type &apos;builtin_function_or_method&apos;&gt;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></li><li><p><a href="https://pypi.python.org/pypi/objgraph/3.1.2" target="_blank" rel="noopener">objgraph</a>模块，可以统计类型对应实例数量，统计类型增长情况，获得指定类型所有实例，<strong>获得指定对象的引用链</strong><img src="/2018/11/10/Python内存泄露查询/objgraph.png" alt="imag"></p></li><li><p><a href="https://pypi.python.org/pypi/memory_profiler/0.50.0" target="_blank" rel="noopener">memory_profiler</a>可对Python代码逐行显示Mem增量，便于发现内存消耗高的代码块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Line #    Mem usage  Increment   Line Contents</span><br><span class="line">==============================================</span><br><span class="line">     3                           @profile</span><br><span class="line">     4      5.97 MB    0.00 MB   def my_func():</span><br><span class="line">     5     13.61 MB    7.64 MB       a = [1] * (10 ** 6)</span><br><span class="line">     6    166.20 MB  152.59 MB       b = [2] * (2 * 10 ** 7)</span><br><span class="line">     7     13.61 MB -152.59 MB       del b</span><br><span class="line">     8     13.61 MB    0.00 MB       return a</span><br></pre></td></tr></table></figure></li><li><p><a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html" target="_blank" rel="noopener">TCMalloc</a><br>Google内存工具，利用tcmalloc 来代替malloc calloc new等等，这样Google Heap Profiler就能知道内存的分配情况，从而分析出内存问题。这种机制可以监测所有程序语言的内存分配情况来分析内存问题。<br>TCMalloc也包括一个堆检查器 和堆分析器。<br><br><a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html" target="_blank" rel="noopener">官网</a><br><br><a href="http://www.cnblogs.com/my_life/articles/4661790.html" target="_blank" rel="noopener">安装</a><br><br><a href="http://blog.csdn.net/jhzhou/article/details/7245992" target="_blank" rel="noopener">使用</a></p></li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://yyc.solvcon.net/writing/2015/pymem_survey.html" target="_blank" rel="noopener">Python内存分析工具文章链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PythonCPU诊断优化</title>
    <link href="http://liangiter.top/2018/11/10/PythonCPU%E8%AF%8A%E6%96%AD%E4%BC%98%E5%8C%96/"/>
    <id>http://liangiter.top/2018/11/10/PythonCPU诊断优化/</id>
    <published>2018-11-10T07:55:50.044Z</published>
    <updated>2018-09-21T07:41:52.348Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>无论用什么语言来实现需求，最后基本都会需要对代码运行时间进行优化，降低cpu占用率</p></blockquote><p>这里主要介绍两个profile工具：</p><ol><li>cProfile：用cProfile生成程序运行时的profile文件，用<code>python pyprof2calltree.py -i file</code>生成文件供QCacheGrind读取；然后用qcachegrind.exe查看，可以看到图像化的代码情况，面积表示cpu占比，可以很方便的找到cpu占比高的代码来进行优化。</li><li>vmprof：vmprof支持pypy，先用vmprof生成profile文件（<code>pypy -m vmprof -o log.jit example.py</code>），用<code>vmprofshow log.jit</code>来查看代码占用cpu情况；</li></ol><p>cprofile图形化结果更加强大，但是不支持pypy。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;无论用什么语言来实现需求，最后基本都会需要对代码运行时间进行优化，降低cpu占用率&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里主要介绍两个profile工具：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;cProfile：用cProfile生成程序运行时的pro
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Pomelo压测.md</title>
    <link href="http://liangiter.top/2018/11/10/pomelo%E5%8E%8B%E6%B5%8B/"/>
    <id>http://liangiter.top/2018/11/10/pomelo压测/</id>
    <published>2018-11-10T07:55:50.010Z</published>
    <updated>2018-09-29T06:25:47.158Z</updated>
    
    <content type="html"><![CDATA[<p>网易开源JavaScript分布式服务器架构Pomelo<br><a href="https://github.com/NetEase/pomelo/wiki/Home-in-Chinese" target="_blank" rel="noopener">中文文档</a></p><p>Pinus一个基于Node.js的分布式水平扩展游戏服务器轻量级强大框架 powered by TypeScript<br><a href="http://pinus.io/" target="_blank" rel="noopener">链接</a></p><blockquote><p>项目对服务器架构进行长久布局，采用网易的分布式游戏服务器Pomelo，需要对Pomelo性能进行压力测试</p></blockquote><!-- ## pomelo chat案例压力测试 --><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>下载pomelo <a href="https://github.com/NetEase/chatofpomelo-websocket.git" target="_blank" rel="noopener">chat聊天室源码</a>，初始化后做如下修改：</p><ul><li>修改<code>game-server/app.js</code>下<code>heartbeat : 3000000</code>，避免压测时因心跳超时而断线</li><li>修改<code>game-server/config/servers.json</code>，所有服务器只保留第一个配置，我们只测试单服单进程的负载</li><li>修改<code>web-server/public/js/client.js</code>，<a href="client.txt">代码传送门</a></li><li>修改<code>game-server/config/log4js.json</code>，将levels下所有的log配置都修改为ERROR（如下），减少后台打印量，避免大量IO影响压测<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"levels"</span>: &#123;</span><br><span class="line">    <span class="string">"rpc-debug"</span> : <span class="string">"ERROR"</span>,</span><br><span class="line">    <span class="string">"pomelo"</span> : <span class="string">"ERROR"</span>,</span><br><span class="line">    <span class="string">"pomelo-admin"</span> : <span class="string">"ERROR"</span>,</span><br><span class="line">    <span class="string">"console"</span> : <span class="string">"ERROR"</span>,</span><br><span class="line">    <span class="string">"pomelo-rpc"</span> : <span class="string">"ERROR"</span>,</span><br><span class="line">    <span class="string">"rpc-log"</span> : <span class="string">"ERROR"</span>,</span><br><span class="line">    <span class="string">"forward-log"</span>: <span class="string">"ERROR"</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li></ul><h3 id="测试方法："><a href="#测试方法：" class="headerlink" title="测试方法："></a>测试方法：</h3><ol><li>进入<code>http://127.0.0.1:3001/</code></li><li>聊天内容匹配<code>profile频率_持续时间</code>，则发起压测；频率为每秒发送消息数量，持续时间为压测持续时间。profile100_5表示每秒100条消息，持续压测5s</li><li>在压测过程中可以用perf工具对node进程进行profile并生成火焰图，<a href="https://www.cnblogs.com/happyliu/p/6142929.html" target="_blank" rel="noopener">profile参考文档</a></li></ol><h3 id="压测数据记录情况"><a href="#压测数据记录情况" class="headerlink" title="压测数据记录情况"></a>压测数据记录情况</h3><hr><blockquote><p>虚拟机压测，配置如下：<br><br>ubuntu-18.04.1-desktop-amd64<br><br>Intel(R) Core(TM) i5-8400 CPU @ 2.80GHz<br><br>RAM: 3.00G<br></p></blockquote><table><thead><tr><th>发包频率</th><th>connector_cpu</th><th>chat_server_cpu</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>10</td><td>1</td><td>1</td></tr><tr><td>100</td><td>5</td><td>1</td></tr><tr><td>500</td><td>28</td><td>6</td></tr><tr><td>1 000</td><td>50</td><td>10</td></tr><tr><td>2 000</td><td>85</td><td>20</td></tr><tr><td>2 500</td><td>95</td><td>25</td></tr></tbody></table><hr><blockquote><p>物理机压测，配置如下：<br><br>Windows 10 专业版 x64<br><br>Intel(R) Core(TM) i5-8400 CPU @ 2.80GHz  2.81GHz<br><br>RAM: 8.00G<br></p></blockquote><table><thead><tr><th>发包频率</th><th>connector_cpu</th><th>chat_server_cpu</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>500</td><td>6</td><td>3</td></tr><tr><td>1 000</td><td>7</td><td>3</td></tr><tr><td>2 000</td><td>15</td><td>6</td></tr><tr><td>5 000</td><td>33</td><td>9</td></tr><tr><td>8 000</td><td>30</td><td>8</td></tr></tbody></table><blockquote><p>当频率=8000，持续时间=30的时候，一共用了140s才将包全部处理完毕，此时的qps为 8000 * 30 / 140 = 1714。虽然此时的cpu并不是满载，但是吞吐量上不去了，Windows下测试比较奇怪。当频率=3000，持续时间=30的时候, qps为3000。当频率=4000，持续时间=30的时候，qps=2608；</p></blockquote><p><code>在ubuntu物理机测试结果最高qps也是3000多</code></p><p>在虚拟机ubuntu中，频率=1000， connector cpu=50，利用perf工具和FlameGraph生成的<a href="cpu.svg">火焰图</a><br><br><img src="/2018/11/10/pomelo压测/cpu.svg" alt="火焰图"><br><br><a href="perf.data">perf.data文件</a><br><br><a href="profile2.txt">easy node profile</a><br><br>目前profile结果还未中的代码还基本未涉及到代码逻辑部分，基本是框架底层固有消耗，还做不到去优化逻辑来提高qps。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在windows物理机和ubuntu物理机下，chat案例的connector最高的qps大约都在3000多<br><br>相对而言，系统的瓶颈是connector，压测中connector的cpu大约是game-server cpu的4倍<br><br>如果4个connector对应一个chat-server，chat-server qps预计能接近1W<br><br>这个这个性能作为棋牌游戏的服务器已经足够，如果作为MMO服务器则略显性能不足，需要用更高效的架构<br></p><p>附上官方测试文档，性能与我们测试的情况相差不大，connector cpu基本上是game-server的4倍<br><br><a href="https://github.com/NetEase/pomelo/wiki/pomelo-rpc%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A" target="_blank" rel="noopener">附pomelo rpc性能测试</a><br><br><a href="https://github.com/NetEase/pomelo/wiki/pomelo-rpc-zeromq%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A" target="_blank" rel="noopener">附pomelo rpc zeromq性能测试</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网易开源JavaScript分布式服务器架构Pomelo&lt;br&gt;&lt;a href=&quot;https://github.com/NetEase/pomelo/wiki/Home-in-Chinese&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中文文档&lt;/a&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Golang性能测试与思考</title>
    <link href="http://liangiter.top/2018/11/10/Golang%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%AF%84%E4%BB%B7/"/>
    <id>http://liangiter.top/2018/11/10/Golang性能测试与评价/</id>
    <published>2018-11-10T07:55:49.990Z</published>
    <updated>2018-09-21T06:37:18.893Z</updated>
    
    <content type="html"><![CDATA[<p>本文测试Go、Python、PyPy、C的效率，作为学习Go的参考标准。测试用例：进行(2&lt;&lt;25)次简单加法</p><blockquote><p>测试环境：<br><br>系统：Windows7 专业版<br><br>CPU：Intel(R) Core(TM) i5-4590 CPU @ 3.30GHZ 3.30GHZ, 14级流水线（Pipeline）<br> </p></blockquote><p>参考资料：<br><a href="https://zh.wikipedia.org/wiki/Core%E5%BE%AE%E6%9E%B6%E6%A7%8B" target="_blank" rel="noopener">Core微架构14级流水线</a></p><p>测试用例：进行(2&lt;&lt;25)次简单加法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang example</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> N <span class="keyword">int</span> = <span class="number">2</span> &lt;&lt; <span class="number">25</span></span><br><span class="line">    <span class="keyword">var</span> j <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    t0 := time.Now()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; (N); i++ &#123;</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    elapsed := time.Since(t0)</span><br><span class="line">    fmt.Println(<span class="string">"N:"</span>, N, <span class="string">"time:"</span>, elapsed)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：N: 67108864 time: 20.5027ms</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># Python and Pypy example</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">t0 = time.clock()</span><br><span class="line"></span><br><span class="line">N = <span class="number">2</span> &lt;&lt; <span class="number">25</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(N):</span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"N:&#123;&#125;, time:&#123;:.2f&#125;ms"</span>.format(N, (time.clock() - t0) * <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>测试结果：<br><br>Python N:67108864, time:5102.14ms<br><br>PyPy: N:67108864, time:124.16ms</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test1.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/timeb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined __linux__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">ClockMs64</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">timeb64</span> <span class="title">timebuffer</span>;</span></span><br><span class="line">    _ftime64_s(&amp;timebuffer);</span><br><span class="line">    <span class="keyword">return</span> timebuffer.time * <span class="number">1000</span> + timebuffer.millitm;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    timespec ts;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == clock_gettime(CLOCK_REALTIME, &amp;ts))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)ts.tv_sec) * <span class="number">1000</span> + ts.tv_nsec/<span class="number">1000000</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">Clock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>)ClockMs64();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    UINT64 N =  <span class="number">2</span> &lt;&lt; <span class="number">25</span>;</span><br><span class="line">    UINT64 j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> start = Clock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(UINT64 i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        j += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> end = Clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"N:%I64d, time:%dms\n"</span>, N, end-start);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：N:67108864, time:160ms</p><p>综合以上测试结果：<br></p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">时间</th></tr></thead><tbody><tr><td style="text-align:left">C</td><td style="text-align:left">160ms</td></tr><tr><td style="text-align:left">PyPy</td><td style="text-align:left">124.16ms</td></tr><tr><td style="text-align:left">Python</td><td style="text-align:left">5102.14ms</td></tr><tr><td style="text-align:left">Golang</td><td style="text-align:left">20.50ms</td></tr></tbody></table><p>结论：从测试结果来看，执行效率Golang &gt; PyPy &gt; C &gt; Python <br><br>分析：<br><br>Golang是编译型语言，会将代码编译成二进制可执行机器码。我们来分析执行Golang的执行时间，我们知道一个汇编指令至少执行一个CPU周期（指令执行整数个周期，大部分指令执行一个周期，指令具体执行周期可以参考CPU手册）。也就是说只要我们知道执行整个程序的汇编指令数量，我们就能对程序运行时间做出评判。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">测试用例循环体内执行以下操作，大致翻译成汇编指令，统计汇编指令数目</span><br><span class="line">1. i &lt; N --&gt; 将i、N入栈，cmp后比较结果来做Jmp操作，大约5条汇编指令；</span><br><span class="line">2. j += 1 --&gt; 将j入栈，执行Inc操作，然后保存到j，大约3条汇编指令；</span><br><span class="line">3. i ++ --&gt; 将i入栈，执行Inc，保存到i，大约3条汇编；</span><br><span class="line">4. 还有一个隐藏的Jump到操作1的操作， 1条汇编</span><br><span class="line"></span><br><span class="line">故一个循环体总体汇编指令条目为(5+3+3+1)=12条</span><br></pre></td></tr></table></figure></p><p>CPU主频为3.30GHZ，循环体汇编条目约为12条。我们以CPU满载、每条指令一个周期计算，执行<code>2&lt;&lt;25</code>次循环体需要用时=1000 <em> ((2&lt;&lt;25) </em> 12) / (3.3 * (10**9)) = 244.03ms。<br>而我们测试Golang用时20.50ms，为什么Golang比前面计算的244.03ms远远要小？秘密在于CPU的指令流水线，根据资料我们知道Intel CPU是14级流水线架构，也就是说一个CPU周期最大可执行14条汇编指令。我们用单级流水线理论时间除以Golang用时：244.03ms / 20.50ms = 11.9，考虑多CPU周期汇编指令的存在和系统调度消耗，14是我们理论上限值，可见结果符合预期。</p><p>Golang在这个测试用例中比C语言更快，更是秒杀Python，超乎预期。通过计算发现Golang的计算效率接近CPU的极限，着实是一门高效的编译型语言。</p><p>另外，附上常见的Benchmark连接<a href="http://benchmarksgame.alioth.debian.org/u64q/task-descriptions.html" target="_blank" rel="noopener">The Computer Language<br>Benchmarks Game</a>，可对比各种语言的性能情况</p><p>参考资料：<br><br><a href="https://zh.wikipedia.org/wiki/Core%E5%BE%AE%E6%9E%B6%E6%A7%8B" target="_blank" rel="noopener">Core微架构-14级流水线</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文测试Go、Python、PyPy、C的效率，作为学习Go的参考标准。测试用例：进行(2&amp;lt;&amp;lt;25)次简单加法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;测试环境：&lt;br&gt;&lt;br&gt;系统：Windows7 专业版&lt;br&gt;&lt;br&gt;CPU：Intel(R) Core(T
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>电影推荐</title>
    <link href="http://liangiter.top/2018/11/10/%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90/"/>
    <id>http://liangiter.top/2018/11/10/电影推荐/</id>
    <published>2018-11-10T07:18:48.000Z</published>
    <updated>2018-11-10T07:44:03.859Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>背景：最近公司要我们每人推荐一部电影，给公司所有人</p></blockquote><p>思来想去，电影看过不少，有创意、有思想、引人深思的电影不多，尤其还与程序员相关的，我首先想起了早年看到的《异次元骇客》。电影讲述一个计算机模拟的虚拟世界中与现实中的其设计者真实世界的交叉，一层一层的解密，真到最后真相大白，令人惊讶。<br><br>看完电影不禁想起一个问题：我是谁，我从何而来，我为什么会存在于这个世界？我们的生活是真实的还是被更高阶智能虚拟出来的呢？<br><br>意大利罗马市政府曾颁布一项奇特的条例，禁止市民用球形的鱼缸养金鱼，理由是，球形鱼缸会混淆鱼的视觉，会扭曲它们对真实世界的观察。但进一步讲，我们人类是否被更高阶智能养在叫做“宇宙”的容器内呢。金鱼在鱼缸中总结出来的鱼缸物理学能算作正确的物理学吗？我们所在的世界是三维的吗，虫洞又是怎么回事？人类对世界的了解，能真正反映真实的世界吗？<br><br>这让我想起霍金在《大设计》，书中讨论生命的来源是否需要上帝的参与，这反映了科学家对人类来源的做出的思考，其中很多观点令人眼界大开。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;背景：最近公司要我们每人推荐一部电影，给公司所有人&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;思来想去，电影看过不少，有创意、有思想、引人深思的电影不多，尤其还与程序员相关的，我首先想起了早年看到的《异次元骇客》。电影讲述一个计算机模拟的虚拟世界中
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Elasticsearch+Kibana</title>
    <link href="http://liangiter.top/2018/10/30/Elasticsearch-Kibana/"/>
    <id>http://liangiter.top/2018/10/30/Elasticsearch-Kibana/</id>
    <published>2018-10-30T09:36:05.000Z</published>
    <updated>2018-11-10T07:17:47.775Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上篇文章介绍了介绍了Fluentd以及EFK机制，最近了解了Elasticsearch，在这里做一个总结</p></blockquote><blockquote><p>Elasticsearch is a search engine based on Lucene. It provides a distributed, multitenant-capable full-text search engine with an HTTP web interface and schema-free JSON documents. Elasticsearch is developed in Java and is released as open source under the terms of the Apache License. Official clients are available in Java, .NET (C#), PHP, Python, Apache Groovy, Ruby and many other languages. According to the DB-Engines ranking, Elasticsearch is the most popular enterprise search engine followed by Apache Solr, also based on Lucene.<br><br><br>Elasticsearch是一个基于Lucene的搜索引擎。它提供了一个分布式、多用户全文搜索引擎，有着HTTP Web界面和无结构JSON文档。Elasticsearch是用Java开发的，并根据Apache License的条款作为开源发布。官方客户端有Java，.NET（C＃），PHP，Python，Apache Groovy，Ruby和许多其他语言版本。根据DB-Engines排名，Elasticsearch是最受欢迎的企业搜索引擎，后面是基于Lucene的Apache Solr。——摘自维基百科</p></blockquote><p>什么是全文搜索？全文检索是指计算机索引程序通过扫描文章中的每一个词，对每一个词建立一个索引，根据索引可以找到文档。我们使用的百度、谷歌等搜索引擎，就是基于这个技术对所有爬取的万维网网页做拆分建立建立全文索引，当我们输入关键字时给我们展现相关的页面。当然，商业搜索引擎还采用竞价排名、PageRank等复杂的算法。</p><p>Elasticsearch是基于开源库Lucene的封装，Lucenej接口使用较为复杂，Elasticsearch使用会更加简单。要明白Elasticsearch机制，首先得搞清楚Lucene是什么。</p><blockquote><p>Lucene是apache软件基金会4 jakarta项目组的一个子项目，是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎（英文与德文两种西方语言）。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎。 ——摘自百度百科</p></blockquote><p>Lucene全词匹配索引的关键技术是用到了FST(Finite State Transducer)——有穷状态转换器。在自然语言处理等领域有很大应用，其功能类似于字典的功能（STL 中的map，C# 中的Dictionary），但其查找是O（1）的，仅仅等于所查找的key长度。目前Lucene4.0在查找Term时就用到了该算法来确定此Term在字典中的位置。<br>关于FST的介绍，可以看这篇博文<a href="https://blog.csdn.net/J_bean/article/details/78660252" target="_blank" rel="noopener">lucene源代码学习之FST(Finite State Transducer)在SynonymFilter中的实现思想</a></p><h3 id="Kibana使用"><a href="#Kibana使用" class="headerlink" title="Kibana使用"></a>Kibana使用</h3><p><img src="/2018/10/30/Elasticsearch-Kibana/kibana.jpg" alt="kibana"><br><img src="/2018/10/30/Elasticsearch-Kibana/kibana2.png" alt="kibana"><br>搜索102246，页面呈现包含搜索字段结果，上方还有以时间为横坐标、log条目为纵坐标的柱状图。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;上篇文章介绍了介绍了Fluentd以及EFK机制，最近了解了Elasticsearch，在这里做一个总结&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Elasticsearch is a search engine base
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Fluentd简介</title>
    <link href="http://liangiter.top/2018/10/18/Fluentd%E7%AE%80%E4%BB%8B/"/>
    <id>http://liangiter.top/2018/10/18/Fluentd简介/</id>
    <published>2018-10-18T01:12:03.000Z</published>
    <updated>2018-10-19T02:25:32.672Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近公司想要统一管理各个项目的日志，也为以后日志可视化查询做一个铺垫。经过筛选，选择了fluentd来做日志的收集转发工作，预想利用EFK来做日志收集、查询、可视化的方案。<br><br>啥？你问我为啥不用Logstash，可参考文章<a href="https://logz.io/blog/fluentd-logstash/" target="_blank" rel="noopener">Fluentd vs. Logstash: A Comparison of Log Collectors</a><br>,两者差异并不大，Fluentd所占内存较小、社区更活跃。</p></blockquote><h3 id="Fluentd是什么？能解决什么问题？"><a href="#Fluentd是什么？能解决什么问题？" class="headerlink" title="Fluentd是什么？能解决什么问题？"></a>Fluentd是什么？能解决什么问题？</h3><p><a href="https://www.fluentd.org/" target="_blank" rel="noopener">官网简介</a>： Fluentd是一个用于统一日志层的开源数据收集器。Fluentd允许您统一数据收集和使用，以便更好地使用和理解数据。Fluentd是云端原生计算基金会(CNCF)的成员项目之一，遵循Apache 2 License协议<br><br>这我们应用中，Fluentd负责从游戏服务器收集日志信息，将数据流交给后续数据存盘、查询工具。换句话说，Fluentd不负责生产数据、不负责存储数据，只是数据的搬运工。</p><ul><li><strong>使用JSON进行统一日志记录</strong>：Fluentd尝试尽可能地将数据结构化为JSON：这允许Fluentd 统一处理日志数据的所有方面：收集，过滤，缓冲和跨多个源和目标（统一日志层）输出日志。使用JSON可以更轻松地进行下游数据处理，因为它具有足够的结构，可以在保留灵活模式的同时进行访问。</li><li><strong>可插拔架构</strong>：Fluentd拥有灵活的插件系统，允许社区扩展其功能。我们的500多个社区贡献插件连接了数十个数据源和数据输出。通过利用插件，您可以立即开始更好地使用日志。</li><li><strong>所需的资源较少</strong>： Fluentd是用C语言和Ruby组合编写的，只需要很少的系统资源。vanilla实例运行30-40MB内存，可处理13,000个事件/秒/核心。</li><li><strong>内置可靠性</strong>：Fluentd支持基于内存和文件的缓冲，以防止节点间数据丢失。Fluentd还支持强大的故障转移功能，可以设置为高可用性。</li></ul><p>注：<a href="https://github.com/fluent/fluentd-benchmark/tree/master/one_forward" target="_blank" rel="noopener">fluentd-benchmark</a> 对简单数据<code>2014-02-20 17:20:55 +0900 [info]: plugin:out_flowcounter_simple count:500       indicator:num   unit:second</code>测压结果是157148次/s</p><p><img src="/2018/10/18/Fluentd简介/fluentd_1.jpg" alt="fluentd log"><br>Fluentd解决数据流流向混乱的问题，通过在两者之间提供统一的日志记录层，从后端系统中分离数据源。</p><h3 id="为什么要用Fluentd？"><a href="#为什么要用Fluentd？" class="headerlink" title="为什么要用Fluentd？"></a>为什么要用Fluentd？</h3><ul><li>简单易用且灵活</li><li>开源</li><li>久经考验的可靠性和性能：5,000多家数据驱动型公司依靠Fluentd通过更好地使用和了解他们的日志数据来区分他们的产品和服务。</li><li><a href="https://www.fluentd.org/community" target="_blank" rel="noopener">活跃的社区</a></li><li>与Logstash相比占用内存更少、社区更活跃，两者比较可参考<a href="https://logz.io/blog/fluentd-logstash/" target="_blank" rel="noopener">Fluentd vs. Logstash: A Comparison of Log Collectors</a></li></ul><p>人气情况：</p><ul><li>github fluent/fluentd start 6.8k</li><li>npm fluent-logger weekly downloads 11,493</li></ul><h3 id="Fluentd的用户："><a href="#Fluentd的用户：" class="headerlink" title="Fluentd的用户："></a>Fluentd的用户：</h3><ul><li>Atlassian</li><li>Microsoft</li><li>amazon</li><li>LINE</li><li>PPTV</li><li>…</li></ul><h4 id="fluentd安装"><a href="#fluentd安装" class="headerlink" title="fluentd安装"></a>fluentd安装</h4><p>fluentd安装、启动可参考<a href="https://docs.fluentd.org/v1.0/articles/quickstart" target="_blank" rel="noopener">Fluent doc</a></p><h4 id="Fluentd配置"><a href="#Fluentd配置" class="headerlink" title="Fluentd配置"></a>Fluentd配置</h4><ul><li>source: 数据源配置，可接受log-tail、http、tcp、udp等方式数据，</li><li>filter: 数据过滤配置，对匹配的tag进行过滤</li><li>match: 数据输出配置，对匹配的tag进行输出设置</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">source</span>&gt;</span><br><span class="line">  @<span class="built_in">type</span> tcp</span><br><span class="line">  tag tcp.events <span class="comment"># required</span></span><br><span class="line">  &lt;parse&gt;</span><br><span class="line">    @<span class="built_in">type</span> regexp</span><br><span class="line">    expression /^(?&lt;field1&gt;\d+):(?&lt;field2&gt;\w+)$/</span><br><span class="line">  &lt;/parse&gt;</span><br><span class="line">  port 5170   <span class="comment"># optional. 5170 by default</span></span><br><span class="line">  <span class="built_in">bind</span> 0.0.0.0 <span class="comment"># optional. 0.0.0.0 by default</span></span><br><span class="line">  delimiter \n <span class="comment"># optional. \n (newline) by default</span></span><br><span class="line">&lt;/<span class="built_in">source</span>&gt;</span><br></pre></td></tr></table></figure><p>Example input:<br><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'123456:awesome'</span> | netcat 0.0.0.0 5170</span><br></pre></td></tr></table></figure></p><p>Parsed result like below:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"field1"</span>:<span class="string">"123456"</span>,<span class="string">"field2"</span>:<span class="string">"awesome&#125;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## built-in TCP input</span></span><br><span class="line"><span class="comment">## @see http://docs.fluentd.org/articles/in_forward</span></span><br><span class="line">&lt;<span class="built_in">source</span>&gt;</span><br><span class="line">  @<span class="built_in">type</span> forward</span><br><span class="line">  @id input_forward</span><br><span class="line">  &lt;security&gt;</span><br><span class="line">    self_hostname input.local</span><br><span class="line">    shared_key liang_handsome</span><br><span class="line">  &lt;/security&gt;</span><br><span class="line">&lt;/<span class="built_in">source</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter example.*.*&gt;</span><br><span class="line">  @<span class="built_in">type</span> grep</span><br><span class="line">  regexp1 levelStr (INFO|WARN|ERROR)</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Match events tagged with "myapp.access" and</span></span><br><span class="line"><span class="comment"># store them to /var/log/fluent/access.%Y-%m-%d</span></span><br><span class="line"><span class="comment"># Of course, you can control how you partition your data</span></span><br><span class="line"><span class="comment"># with the time_slice_format option.</span></span><br><span class="line">&lt;match example.*.*&gt;</span><br><span class="line">  @<span class="built_in">type</span> file</span><br><span class="line">  path E:\software\fluentd\td-agent\<span class="built_in">log</span>\output_file</span><br><span class="line">&lt;/match&gt;</span><br></pre></td></tr></table></figure><p><code>fluentd更多配置请参考官网:https://docs.fluentd.org/v1.0/articles/config-file</code></p><h3 id="fluent-logger配置"><a href="#fluent-logger配置" class="headerlink" title="fluent-logger配置"></a>fluent-logger配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;configure, getLogger, shutdown&#125; <span class="keyword">from</span> <span class="string">'log4js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fluentAppender = configure(&#123;</span><br><span class="line">  appenders: &#123;</span><br><span class="line">    <span class="string">"fluent"</span>: &#123;</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"log4js-fluent-appender"</span>,</span><br><span class="line">      <span class="string">"tag_prefix"</span>: <span class="string">"example.your_keys"</span>,</span><br><span class="line">      <span class="string">"options"</span>: &#123;</span><br><span class="line">        <span class="string">"levelTag"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"host"</span>: <span class="string">"localhost"</span>,</span><br><span class="line">        <span class="string">"port"</span>: <span class="number">24224</span>,</span><br><span class="line">        <span class="string">"timeout"</span>: <span class="number">3.0</span>,</span><br><span class="line">        <span class="string">"reconnectInterval"</span>: <span class="number">600000</span>,</span><br><span class="line">        <span class="string">"security"</span>: &#123;</span><br><span class="line">          <span class="string">"clientHostname"</span>: <span class="string">"client"</span>,</span><br><span class="line">          <span class="string">"sharedKey"</span>: <span class="string">"liang_handsome"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  categories: &#123;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      appenders: [<span class="string">'fluent'</span>],</span><br><span class="line">      level: <span class="string">'info'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如上配置，fluent-logger根据host、port连接fluentd，sharedKey作为连接认证</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.info(&#123;<span class="attr">log_type</span>: <span class="string">"create-room"</span>, <span class="attr">uuid</span>: <span class="number">1112</span>, <span class="attr">room_id</span>: <span class="number">234</span>, <span class="attr">config</span>: &#123;<span class="attr">cards</span>: <span class="number">16</span>, <span class="attr">chairs</span>: <span class="number">3</span>&#125;&#125;);</span><br></pre></td></tr></table></figure><p>fluentd输出为:<br><br><code>2018-10-18T10:50:38+08:00    example.your_keys.INFO    {&quot;timestamp&quot;:1539831038583.0,&quot;category&quot;:&quot;default&quot;,&quot;levelInt&quot;:20000,&quot;levelStr&quot;:&quot;INFO&quot;,&quot;context&quot;:{},&quot;data&quot;:&quot;log { log_type: &#39;create-room&#39;, uuid: 1112, room_id: 234 }&quot;}</code></p><h3 id="JavaScript-fluent-logger缓存测试："><a href="#JavaScript-fluent-logger缓存测试：" class="headerlink" title="JavaScript fluent_logger缓存测试："></a>JavaScript fluent_logger缓存测试：</h3><ul><li>在fluentd关闭的情况下，logger输出20条日志，开启fluentd，fluent-logger会自动连接上fluentd，并将缓存的20条log发送至fluentd</li><li>正常连接fluentd，输出5条log。然后关闭fluentd，继续输出15条log，启动fluentd，fluent-logger自动连接上fluentd，并将缓存的15条log发送至fluentd</li></ul><p>以上测试表明fluentd-logger在与fluentd丢失连接时，相关log暂先会缓存起来，并在重连时将缓存的log发送至fluentd。这个机制相当优秀，大大增加了安全性，不过要注意缓存是占用内存的，如果长时间连接不上fluentd，有内存耗尽的风险。</p><h3 id="日志解决方案实战"><a href="#日志解决方案实战" class="headerlink" title="日志解决方案实战"></a>日志解决方案实战</h3><p>可参考文档：<a href="https://blog.csdn.net/shiwenqing/article/details/50475330" target="_blank" rel="noopener">基于Elasticsearch+Fluentd+Kibana的日志收集分析系统搭建与应用</a><br></p><h3 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h3><p>fluentd收集数据，可输出到hadoop中，利用数据做数据挖掘，可以实现很多有价值的目标。比如：</p><ul><li>监测用户行为，针对流失较高的点，优化流失率，提高留存</li><li>监测消费行为，针对性营销，增加收入</li><li>异常检测，发现数据异常情况，第一时间发现服务器逻辑漏洞</li><li>消费数据挖掘，将消费者分类，同类消费者商品推荐</li><li>发现即将流失客户，重点给与相关优惠吸引策略</li><li>发现核心用户，重点关注</li><li>…</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.fluentd.org/" target="_blank" rel="noopener">Fluent</a><br><br><a href="https://github.com/fluent/fluentd-benchmark/tree/master/one_forward" target="_blank" rel="noopener">fluentd-benchmark</a><br><br><a href="https://docs.fluentd.org/v1.0/articles/quickstart" target="_blank" rel="noopener">Fluent doc</a><br><br><a href="https://blog.csdn.net/shiwenqing/article/details/50475330" target="_blank" rel="noopener">基于Elasticsearch+Fluentd+Kibana的日志收集分析系统搭建与应用</a><br><br><a href="https://logz.io/blog/fluentd-logstash/" target="_blank" rel="noopener">Fluentd vs. Logstash: A Comparison of Log Collectors</a><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近公司想要统一管理各个项目的日志，也为以后日志可视化查询做一个铺垫。经过筛选，选择了fluentd来做日志的收集转发工作，预想利用EFK来做日志收集、查询、可视化的方案。&lt;br&gt;&lt;br&gt;啥？你问我为啥不用Logstash，可参考文章&lt;a href
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>内存管理</title>
    <link href="http://liangiter.top/2018/09/29/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://liangiter.top/2018/09/29/内存管理/</id>
    <published>2018-09-29T11:27:34.000Z</published>
    <updated>2018-10-09T01:47:43.779Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote><p>内存管理不恰当，会有造成大量内存碎片、内存分配效率低、内存实际使用率低。在程序运行中，这些问题会导致程序无法持久正常运行，于服务器技术而言更是如此。</p></blockquote><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>内存管理可以分为三个层次，自底向上分别是：</p><ul><li>操作系统内核的内存管理</li><li>使用系统调用维护的内存管理算法</li><li>在上一步基础上，根据应用程序本身的程序特性进行优化， 比如使用引用计数、内存池方式等</li></ul><p><strong>本文我们主要讨论第二步的使用系统调用维护的内存管理算法</strong></p><p>对于需要持久运行的程序而言，内存管理十分重要，一个优秀的内存管理策略应该具有如下特性：</p><ul><li>分配速度尽可能快</li><li>内存碎片尽可能少</li><li>内存实际使用率高</li></ul><h3 id="memcached内存管理机制"><a href="#memcached内存管理机制" class="headerlink" title="memcached内存管理机制"></a>memcached内存管理机制</h3><blockquote><p>memcached是一个知名的高效的分布式内存cache，默认使用SlabAllocation机制管理内存，其主要思想是按照预先规定的大小，将分配的内存分割成特定长度的块以存储相应长度的key-value数据记录，以完全解决内存碎片问题。</p></blockquote><p>Slab和Chunk<br><br><img src="/2018/09/29/内存管理/memcached内存结构图.png" alt="memcached内存结构图"><br><br>slab是memcached一次申请内存的最小单位。memcached启动时使用参数-m指定其可用内存，但并不是启动时所有的内存就全部分配出去了，只有在需要时才会去申请，而且每次申请一定是一个slab。Slab的大小固定为1M（1048576 Byte）。</p><p>一个slab由若干个大小相等的chunk组成。每个chunk中都保存了一个item结构体、一对key和value。</p><p>虽然在同一个slab中chunk的大小相等的，但是在不同的slab中chunk的大小并不一定相等，在memcached中按照chunk的大小不同，可以把slab分为很多种类（class）。</p><p>在启动memcached的时候可以通过-vv来查看slab的种类：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ memcached -vv</span><br><span class="line">slab class <span class="number">1</span>: chunk size <span class="number">80</span> perslab <span class="number">13107</span></span><br><span class="line">slab class <span class="number">2</span>: chunk size <span class="number">104</span> perslab <span class="number">10082</span></span><br><span class="line">slab class <span class="number">3</span>: chunk size <span class="number">136</span> perslab <span class="number">7710</span></span><br><span class="line">slab class <span class="number">4</span>: chunk size <span class="number">176</span> perslab <span class="number">5957</span></span><br><span class="line">slab class <span class="number">5</span>: chunk size <span class="number">224</span> perslab <span class="number">4681</span></span><br><span class="line">slab class <span class="number">6</span>: chunk size <span class="number">280</span> perslab <span class="number">3744</span></span><br><span class="line">slab class <span class="number">7</span>: chunk size <span class="number">352</span> perslab <span class="number">2978</span></span><br><span class="line">slab class <span class="number">8</span>: chunk size <span class="number">440</span> perslab <span class="number">2383</span></span><br><span class="line">slab class <span class="number">9</span>: chunk size <span class="number">552</span> perslab <span class="number">1899</span></span><br><span class="line">slab class <span class="number">10</span>: chunk size <span class="number">696</span> perslab <span class="number">1506</span></span><br><span class="line">slab class <span class="number">11</span>: chunk size <span class="number">872</span> perslab <span class="number">1202</span></span><br><span class="line">slab class <span class="number">12</span>: chunk size <span class="number">1096</span> perslab <span class="number">956</span></span><br><span class="line">slab class <span class="number">13</span>: chunk size <span class="number">1376</span> perslab <span class="number">762</span></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br></pre></td></tr></table></figure><p>向memcached添加item时，memcached首先会根据item大小，根据chunk size向上取整，来选择接近的slab class。例如，item大小为156，向上取最小的chunk size为176.</p><p>memcached采取SlabAllocation策略，一次向系统申请1M空间内存作为slab。slab根据其chunk size分割成等大的内存块chunk，每个chunk都可以存储一个item。memcached内存分配做到了一次申请大量空间，分割多块给小对象多次使用，大大降低了向操作系统申请内存的时间，大部分内存管理机制都会用到这个策略。<br><br>其次，memcached将slab按chunk size分组，将每一个slab内部按chunk size分割成固定大小的内存块。固定大小的chunk，回收之后还可以用于下一次item的存储，内存的分布情况不会变的错综复杂，有利于减少内存碎片。chunk size递增策略，每一次item都向上取到最接近的chunk size对应的slab来存储，有利于提高其实际内存利用率<br></p><h3 id="Redis内存管理机制"><a href="#Redis内存管理机制" class="headerlink" title="Redis内存管理机制"></a>Redis内存管理机制</h3><blockquote><p>Redis默认使用jemalloc作为内存分配器。jemalloc 是一个通用的 malloc（3）实现，它强调了分段回避和可伸缩并发支持。jemalloc 在 2005 年首次作为 FreeBSD libc 分配器使用，2010年，jemalloc 的功能延伸到如堆分析和监控/调优等。现代的 jemalloc 版本依然集成在 FreeBSD 中。</p></blockquote><p>jemalloc机制相对memcached的SlabAllocation策略来说比较复杂，这里不做详细介绍，详情可参考本文列出的参考文档。</p><p>类似的，对jemalloc策略总结如下：</p><ul><li>一次向系统申请大内存4M（chunk），供之后多次使用</li><li>将控制的内存分成不同大小的小内存块（bins），重复使用</li><li>存放对象时，向上找到最接近size的bin对应的空闲内存块来存储</li><li>每个线程有自己的独立空间tcache，将内存划分为arena供线程使用，减少线程间的互斥访问</li></ul><p>前三条策略的思想与memcached的SlabAllocationc策略所蕴含的思想一致，第四条策略是针对多线程加速的优化。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://blog.csdn.net/junlon2006/article/details/77854898" target="_blank" rel="noopener"><strong>内存优化总结:ptmalloc、tcmalloc和jemalloc</strong></a><br><br><a href="https://blog.csdn.net/peerless_hero/article/details/77061927" target="_blank" rel="noopener"><strong>memcached的内存管理机制</strong></a><br><br><a href="https://www.cnblogs.com/gaoxing/p/4253833.html" target="_blank" rel="noopener"><strong>jemalloc和内存管里</strong></a><br><br><a href="https://people.freebsd.org/~jasone/jemalloc/bsdcan2006/jemalloc.pdf" target="_blank" rel="noopener"><strong>A Scalable Concurrent malloc(3) Implementation for FreeBSD</strong></a><br><br><a href="https://blog.csdn.net/koozxcv/article/details/50973217" target="_blank" rel="noopener"><strong>jemalloc内存分配器详解</strong></a><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;内存管理不恰当，会有造成大量内存碎片、内存分配效率低、内存实际使用率低。在程序运行中，这些问题会导致程序无法持久正
      
    
    </summary>
    
    
  </entry>
  
</feed>
